{"version":3,"sources":["constraint-solver/datatypes.js","constraint-solver/catalog-cache.js","constraint-solver/catalog-loader.js","constraint-solver/constraint-solver-input.js"],"names":[],"mappings":";;;;;;;;AAAA,sB;;AAEA,wB;AACA,0B;;AAEA,4B;;AAEA,yC;AACA,oD;AACA,yB;AACA,yB;;AAEA,yB;AACA,yB;AACA,E;;AAEA,+D;AACA,8D;AACA,mD;AACA,uD;AACA,2C;AACA,E;;AAEA,kD;AACA,6B;AACA,mD;AACA,wD;AACA,U;AACA,2D;AACA,G;AACA,E;;AAEA,qB;;AAEA,mE;AACA,4B;;AAEA,qD;AACA,sE;AACA,8C;AACA,8D;AACA,G;AACA,c;AACA,yB;AACA,G;;AAEA,uC;AACA,sB;;AAEA,c;AACA,uB;AACA,yB;AACA,K;AACA,G;AACA,E;;AAEA,6D;AACA,6D;AACA,gD;AACA,wC;AACA,oB;AACA,oB;AACA,G;AACA,a;AACA,E;;AAEA,2C;AACA,qB;;AAEA,8B;AACA,kB;AACA,uB;AACA,G;;AAEA,+C;;AAEA,uC;AACA,E;;;;;;;;;;;;;;;;;;;AC7EA,0B;;AAEA,yC;AACA,iC;AACA,E;;AAEA,4D;AACA,+B;AACA,uD;AACA,8E;AACA,0B;AACA,yE;AACA,mC;AACA,qD;AACA,sB;AACA,E;;AAEA,2E;AACA,4D;AACA,E;;AAEA,qE;AACA,mB;AACA,mB;AACA,qE;AACA,+B;;AAEA,wB;AACA,uC;AACA,wD;AACA,G;;AAEA,mC;AACA,2B;AACA,G;AACA,4B;;AAEA,yB;AACA,0C;AACA,6B;AACA,gC;AACA,mC;AACA,8D;AACA,oC;AACA,K;AACA,0B;AACA,K;AACA,E;;AAEA,qE;AACA,wD;AACA,iD;AACA,8D;AACA,wB;AACA,yC;AACA,2C;AACA,G;AACA,iC;AACA,E;;AAEA,iE;AACA,6B;AACA,mE;AACA,0C;AACA,wC;AACA,E;;AAEA,oD;AACA,kB;AACA,gB;AACA,4D;AACA,sD;AACA,qD;AACA,qD;AACA,4B;AACA,O;AACA,K;AACA,wB;AACA,E;;AAEA,+C;AACA,+B;;AAEA,oC;AACA,6C;AACA,+B;AACA,6C;AACA,4B;AACA,6B;AACA,uC;AACA,6C;AACA,U;AACA,K;AACA,e;AACA,E;;AAEA,yE;AACA,kE;AACA,wB;AACA,gE;AACA,kB;AACA,uC;AACA,yD;AACA,6C;AACA,e;AACA,Y;AACA,K;AACA,G;AACA,E;;AAEA,oE;AACA,uE;AACA,gD;AACA,uE;AACA,kB;AACA,mC;AACA,uD;AACA,e;AACA,Y;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACzHA,wB;AACA,0B;;AAEA,qE;AACA,6D;AACA,gD;AACA,E;AACA,sE;AACA,oE;AACA,oE;AACA,mE;AACA,kE;AACA,iE;AACA,8D;AACA,mE;AACA,iC;;AAEA,2D;AACA,kB;;AAEA,6B;AACA,qC;;AAEA,uC;AACA,E;;AAEA,8C;AACA,E;AACA,4C;AACA,6C;AACA,E;AACA,sD;AACA,sD;AACA,4D;;AAEA,0C;AACA,qD;AACA,0D;AACA,gD;AACA,yD;AACA,uB;AACA,O;;AAEA,8C;AACA,kE;AACA,wB;AACA,K;;AAEA,2E;AACA,+D;AACA,K;AACA,E;;AAEA,qE;AACA,uD;AACA,0E;AACA,0D;AACA,8C;AACA,oD;AACA,G;;AAEA,kD;AACA,E;;AAEA,iE;AACA,kB;AACA,gC;AACA,2D;AACA,sC;AACA,8B;AACA,sD;AACA,+C;AACA,sD;AACA,K;AACA,K;AACA,E;;AAEA,yE;AACA,yB;AACA,8E;AACA,kB;;AAEA,0E;AACA,uE;AACA,wE;AACA,iD;AACA,qB;AACA,gC;;AAEA,oC;AACA,iD;AACA,2C;AACA,8B;AACA,K;AACA,I;;AAEA,+B;;AAEA,4B;AACA,kC;AACA,kC;AACA,wE;AACA,kE;AACA,+C;AACA,0B;AACA,S;AACA,O;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC5GA,wB;AACA,0B;;AAEA,qE;AACA,oE;AACA,4D;AACA,wE;AACA,0B;;AAEA,mC;AACA,iC;AACA,uC;AACA,qE;AACA,2D;;AAEA,qC;AACA,mD;AACA,gC;AACA,oC;AACA,iE;AACA,0D;;AAEA,mC;AACA,E;;AAEA,+D;AACA,kB;;AAEA,6C;;AAEA,gD;AACA,mC;AACA,K;AACA,kD;AACA,2C;AACA,K;AACA,6D;AACA,mC;AACA,K;;AAEA,kE;AACA,iE;AACA,E;;AAEA,6C;AACA,kB;AACA,a;AACA,oC;AACA,uD;AACA,0B;AACA,O;AACA,gD;AACA,I;AACA,iE;AACA,wC;AACA,4B;AACA,+B;AACA,G;AACA,iD;AACA,6D;AACA,G;AACA,uC;AACA,iD;AACA,I;AACA,a;AACA,E;;AAEA,wC;AACA,c;AACA,2B;AACA,0B;AACA,yB;AACA,2C;AACA,+D;AACA,gE;AACA,qC;AACA,K;;AAEA,sB;AACA,qB;AACA,4C;AACA,sC;AACA,O;AACA,mD;AACA,K;AACA,2B;AACA,yD;AACA,4C;AACA,O;AACA,E;;AAEA,oE;AACA,kE;AACA,qE;AACA,kE;AACA,sE;AACA,qD;AACA,wC;AACA,uB;AACA,6B;AACA,0B;AACA,6B;AACA,+C;AACA,kB;AACA,Q;AACA,qC;AACA,M;;AAEA,wC;AACA,uB;AACA,4B;AACA,0B;AACA,sC;AACA,gD;AACA,oC;AACA,M","file":"/packages/constraint-solver.js","sourcesContent":["ConstraintSolver = {};\n\nvar PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n////////// PackageAndVersion\n\n// An ordered pair of (package, version).\nCS.PackageAndVersion = function (package, version) {\n  check(package, String);\n  check(version, String);\n\n  this.package = package;\n  this.version = version;\n};\n\n// The string form of a PackageAndVersion is \"package version\",\n// for example \"foo 1.0.1\".  The reason we don't use an \"@\" is\n// it would look too much like a PackageConstraint.\nCS.PackageAndVersion.prototype.toString = function () {\n  return this.package + \" \" + this.version;\n};\n\nCS.PackageAndVersion.fromString = function (str) {\n  var parts = str.split(' ');\n  if (parts.length === 2 && parts[0] && parts[1]) {\n    return new CS.PackageAndVersion(parts[0], parts[1]);\n  } else {\n    throw new Error(\"Malformed PackageAndVersion: \" + str);\n  }\n};\n\n////////// Dependency\n\n// A Dependency consists of a PackageConstraint (like \"foo@=1.2.3\")\n// and flags, like \"isWeak\".\n\nCS.Dependency = function (packageConstraint, flags) {\n  check(packageConstraint, Match.OneOf(PV.PackageConstraint, String));\n  if (typeof packageConstraint === 'string') {\n    packageConstraint = PV.parseConstraint(packageConstraint);\n  }\n  if (flags) {\n    check(flags, Object);\n  }\n\n  this.pConstraint = packageConstraint;\n  this.isWeak = false;\n\n  if (flags) {\n    if (flags.isWeak) {\n      this.isWeak = true;\n    }\n  }\n};\n\n// The string form of a Dependency is `?foo@1.0.0` for a weak\n// reference to package \"foo\" with VersionConstraint \"1.0.0\".\nCS.Dependency.prototype.toString = function () {\n  var ret = this.pConstraint.toString();\n  if (this.isWeak) {\n    ret = '?' + ret;\n  }\n  return ret;\n};\n\nCS.Dependency.fromString = function (str) {\n  var isWeak = false;\n\n  if (str.charAt(0) === '?') {\n    isWeak = true;\n    str = str.slice(1);\n  }\n\n  var flags = isWeak ? { isWeak: true } : null;\n\n  return new CS.Dependency(str, flags);\n};\n","var CS = ConstraintSolver;\n\nvar pvkey = function (package, version) {\n  return package + \" \" + version;\n};\n\n// Stores the Dependencies for each known PackageAndVersion.\nCS.CatalogCache = function () {\n  // String(PackageAndVersion) -> String -> Dependency.\n  // For example, \"foo 1.0.0\" -> \"bar\" -> Dependency.fromString(\"?bar@1.0.2\").\n  this._dependencies = {};\n  // A map derived from the keys of _dependencies, for ease of iteration.\n  // \"package\" -> [\"versions\", ...]\n  // Versions in the array are unique but not sorted.\n  this._versions = {};\n};\n\nCS.CatalogCache.prototype.hasPackageVersion = function (package, version) {\n  return _.has(this._dependencies, pvkey(package, version));\n};\n\nCS.CatalogCache.prototype.addPackageVersion = function (p, v, deps) {\n  check(p, String);\n  check(v, String);\n  // `deps` must not have any duplicate values of `.pConstraint.name`\n  check(deps, [CS.Dependency]);\n\n  var key = pvkey(p, v);\n  if (_.has(this._dependencies, key)) {\n    throw new Error(\"Already have an entry for \" + key);\n  }\n\n  if (! _.has(this._versions, p)) {\n    this._versions[p] = [];\n  }\n  this._versions[p].push(v);\n\n  var depsByPackage = {};\n  this._dependencies[key] = depsByPackage;\n  _.each(deps, function (d) {\n    var p2 = d.pConstraint.name;\n    if (_.has(depsByPackage, p2)) {\n      throw new Error(\"Can't have two dependencies on \" + p2 +\n                      \" in \" + key);\n    }\n    depsByPackage[p2] = d;\n  });\n};\n\n// Returns the dependencies of a (package, version), stored in a map.\n// The values are Dependency objects; the key for `d` is\n// `d.pConstraint.name`.  (Don't mutate the map.)\nCS.CatalogCache.prototype.getDependencyMap = function (p, v) {\n  var key = pvkey(p, v);\n  if (! _.has(this._dependencies, key)) {\n    throw new Error(\"No entry for \" + key);\n  }\n  return this._dependencies[key];\n};\n\n// Returns an array of version strings, unsorted, possibly empty.\n// (Don't mutate the result.)\nCS.CatalogCache.prototype.getPackageVersions = function (package) {\n  return (_.has(this._versions, package) ?\n          this._versions[package] : []);\n};\n\nCS.CatalogCache.prototype.toJSONable = function () {\n  var self = this;\n  var data = {};\n  _.each(self._dependencies, function (depsByPackage, key) {\n    // depsByPackage is a map of String -> Dependency.\n    // Map over the values to get an array of String.\n    data[key] = _.map(depsByPackage, function (dep) {\n      return dep.toString();\n    });\n  });\n  return { data: data };\n};\n\nCS.CatalogCache.fromJSONable = function (obj) {\n  check(obj, { data: Object });\n\n  var cache = new CS.CatalogCache();\n  _.each(obj.data, function (depsArray, pv) {\n    check(depsArray, [String]);\n    pv = CS.PackageAndVersion.fromString(pv);\n    cache.addPackageVersion(\n      pv.package, pv.version,\n      _.map(depsArray, function (str) {\n        return CS.Dependency.fromString(str);\n      }));\n  });\n  return cache;\n};\n\n// Calls `iter` on each PackageAndVersion, with the second argument being\n// a map from package name to Dependency.  If `iter` returns true,\n// iteration is stopped.\nCS.CatalogCache.prototype.eachPackageVersion = function (iter) {\n  var self = this;\n  for (var key in self._dependencies) {\n    var stop = iter(CS.PackageAndVersion.fromString(key),\n                    self._dependencies[key]);\n    if (stop) {\n      break;\n    }\n  }\n};\n\n// Calls `iter` on each package name, with the second argument being\n// a list of versions present for that package (unique but not sorted).\n// If `iter` returns true, iteration is stopped.\nConstraintSolver.CatalogCache.prototype.eachPackage = function (iter) {\n  var self = this;\n  for (var key in self._versions) {\n    var stop = iter(key, self.getPackageVersions(key));\n    if (stop) {\n      break;\n    }\n  }\n};\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// A CatalogLoader populates the CatalogCache from the Catalog.  When\n// running unit tests with no Catalog and canned data for the\n// CatalogCache, there will be no CatalogLoader.\n//\n// Fine-grained Loading: While we don't currently support loading only\n// some versions of a package, CatalogLoader is meant to be extended\n// to support incrementally loading individual package versions.  It\n// has no concept of a \"loaded package,\" for example, just a loaded\n// package version.  CatalogLoader's job, in principle, is to load\n// package versions efficiently, no matter the access pattern, by\n// making the right catalog calls and doing the right caching.\n// Calling a catalog method generally means running a SQLite query,\n// which could be time-consuming.\n\nCS.CatalogLoader = function (fromCatalog, toCatalogCache) {\n  var self = this;\n\n  self.catalog = fromCatalog;\n  self.catalogCache = toCatalogCache;\n\n  self._sortedVersionRecordsCache = {};\n};\n\n// We rely on the following `catalog` methods:\n//\n// * getSortedVersionRecords(packageName) ->\n//     [{packageName, version, dependencies}]\n//\n//   Where `dependencies` is a map from packageName to\n//   an object of the form `{ constraint: String|null,\n//   references: [{arch: String, optional \"weak\": true}] }`.\n\nvar convertDeps = function (catalogDeps) {\n  return _.map(catalogDeps, function (dep, package) {\n    // The dependency is strong if any of its \"references\"\n    // (for different architectures) are strong.\n    var isStrong = _.any(dep.references, function (ref) {\n      return !ref.weak;\n    });\n\n    var constraint = (dep.constraint || null);\n    if (constraint === 'none') { // not sure where this comes from\n      constraint = null;\n    }\n\n    return new CS.Dependency(new PV.PackageConstraint(package, constraint),\n                             isStrong ? null : {isWeak: true});\n  });\n};\n\n// Since we don't fetch different versions of a package independently\n// at the moment, this helper is where we get our data.\nCS.CatalogLoader.prototype._getSortedVersionRecords = function (package) {\n  if (! _.has(this._sortedVersionRecordsCache, package)) {\n    this._sortedVersionRecordsCache[package] =\n      this.catalog.getSortedVersionRecords(package);\n  }\n\n  return this._sortedVersionRecordsCache[package];\n};\n\nCS.CatalogLoader.prototype.loadAllVersions = function (package) {\n  var self = this;\n  var cache = self.catalogCache;\n  var versionRecs = self._getSortedVersionRecords(package);\n  _.each(versionRecs, function (rec) {\n    var version = rec.version;\n    if (! cache.hasPackageVersion(package, version)) {\n      var deps = convertDeps(rec.dependencies);\n      cache.addPackageVersion(package, version, deps);\n    }\n  });\n};\n\n// Takes an array of package names.  Loads all versions of them and their\n// (strong) dependencies.\nCS.CatalogLoader.prototype.loadAllVersionsRecursive = function (packageList) {\n  var self = this;\n\n  // Within a call to loadAllVersionsRecursive, we only visit each package\n  // at most once.  If we visit a package we've already loaded, it will\n  // lead to a quick scan through the versions in our cache to make sure\n  // they have been loaded into the CatalogCache.\n  var loadQueue = [];\n  var packagesEverEnqueued = {};\n\n  var enqueue = function (package) {\n    if (! _.has(packagesEverEnqueued, package)) {\n      packagesEverEnqueued[package] = true;\n      loadQueue.push(package);\n    }\n  };\n\n  _.each(packageList, enqueue);\n\n  while (loadQueue.length) {\n    var package = loadQueue.pop();\n    self.loadAllVersions(package);\n    _.each(self.catalogCache.getPackageVersions(package), function (v) {\n      var depMap = self.catalogCache.getDependencyMap(package, v);\n      _.each(depMap, function (dep, package2) {\n        enqueue(package2);\n      });\n    });\n  }\n};\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// The \"Input\" object completely specifies the input to the resolver,\n// and it holds the data loaded from the Catalog as well.  It can be\n// serialized to JSON and read back in for testing purposes.\nCS.Input = function (dependencies, constraints, catalogCache, options) {\n  options = options || {};\n\n  this.dependencies = dependencies;\n  this.constraints = constraints;\n  this.upgrade = options.upgrade || [];\n  this.anticipatedPrereleases = options.anticipatedPrereleases || {};\n  this.previousSolution = options.previousSolution || null;\n\n  check(this.dependencies, [String]);\n  check(this.constraints, [PackageConstraintType]);\n  check(this.upgrade, [String]);\n  check(this.anticipatedPrereleases,\n        Match.ObjectWithValues(Match.ObjectWithValues(Boolean)));\n  check(this.previousSolution, Match.OneOf(Object, null));\n\n  this.catalogCache = catalogCache;\n};\n\nCS.Input.prototype.loadFromCatalog = function (catalogLoader) {\n  var self = this;\n\n  var packagesToLoad = {}; // package -> true\n\n  _.each(self.dependencies, function (package) {\n    packagesToLoad[package] = true;\n  });\n  _.each(self.constraints, function (constraint) {\n    packagesToLoad[constraint.name] = true;\n  });\n  _.each(self.previousSolution, function (version, package) {\n    packagesToLoad[package] = true;\n  });\n\n  // Load packages into the cache (if they aren't loaded already).\n  catalogLoader.loadAllVersionsRecursive(_.keys(packagesToLoad));\n};\n\nCS.Input.prototype.toJSONable = function () {\n  var self = this;\n  var obj = {\n    dependencies: self.dependencies,\n    constraints: _.map(self.constraints, function (c) {\n      return c.toString();\n    }),\n    catalogCache: self.catalogCache.toJSONable()\n  };\n  // For readability of the resulting JSON, only include optional\n  // properties that aren't the default.\n  if (self.upgrade.length) {\n    obj.upgrade = self.upgrade;\n  }\n  if (! _.isEmpty(self.anticipatedPrereleases)) {\n    obj.anticipatedPrereleases = self.anticipatedPrereleases;\n  }\n  if (self.previousSolution !== null) {\n    obj.previousSolution = self.previousSolution;\n  };\n  return obj;\n};\n\nCS.Input.fromJSONable = function (obj) {\n  check(obj, {\n    dependencies: [String],\n    constraints: [String],\n    catalogCache: Object,\n    anticipatedPrereleases: Match.Optional(\n      Match.ObjectWithValues(Match.ObjectWithValues(Boolean))),\n    previousSolution: Match.Optional(Match.OneOf(Object, null)),\n    upgrade: Match.Optional([String])\n  });\n\n  return new CS.Input(\n    obj.dependencies,\n    _.map(obj.constraints, function (cstr) {\n      return PV.parseConstraint(cstr);\n    }),\n    CS.CatalogCache.fromJSONable(obj.catalogCache),\n    {\n      upgrade: obj.upgrade,\n      anticipatedPrereleases: obj.anticipatedPrereleases,\n      previousSolution: obj.previousSolution\n    });\n};\n\n// PackageConstraints and VersionConstraints passed in from the tool\n// to us (where we are a uniloaded package) will have constructors\n// that we don't recognize because they come from a different copy of\n// package-version-parser!  In addition, objects with constructors\n// can't be checked by \"check\" in the same way as plain objects, so we\n// have to resort to examining the fields explicitly.\nvar VersionConstraintType = Match.OneOf(\n  PV.VersionConstraint,\n  Match.Where(function (vc) {\n    check(vc.raw, String);\n    check(vc.alternatives, [{\n      versionString: Match.OneOf(String, null),\n      type: String\n    }]);\n    return vc.constructor !== Object;\n  }));\n\nvar PackageConstraintType = Match.OneOf(\n  PV.PackageConstraint,\n  Match.Where(function (c) {\n    check(c.name, String);\n    check(c.constraintString, String);\n    check(c.vConstraint, VersionConstraintType);\n    return c.constructor !== Object;\n  }));\n"]}
{"version":3,"file":"/packages/constraint-solver.js","sources":["constraint-solver/constraint-solver.js","constraint-solver/resolver.js","constraint-solver/constraints-list.js","constraint-solver/resolver-state.js","constraint-solver/priority-queue.js"],"names":[],"mappings":";;;;;;;;AAAA,2C;AACA,6C;AACA,wD;AACA,uC;AACA,8C;AACA,E;;AAEA,sB;;AAEA,uE;AACA,mE;AACA,oE;AACA,qE;AACA,M;AACA,iE;AACA,kB;;AAEA,0B;;AAEA,yB;;AAEA,sB;AACA,iD;AACA,wB;AACA,K;;AAEA,kC;AACA,kC;AACA,mC;AACA,E;;AAEA,iF;AACA,kB;AACA,kB;AACA,qD;AACA,W;AACA,iD;AACA,+C;;AAEA,2E;AACA,2B;AACA,uD;AACA,+B;AACA,W;;AAEA,kC;AACA,O;AACA,+C;AACA,+D;AACA,6C;AACA,K;AACA,a;AACA,qC;AACA,G;AACA,E;;AAEA,yE;AACA,kB;AACA,kB;;AAEA,0E;AACA,mE;AACA,wC;AACA,sD;;AAEA,0E;AACA,+E;AACA,mE;AACA,6C;AACA,mE;;AAEA,uB;;AAEA,sC;AACA,8C;AACA,6D;AACA,iE;AACA,wD;AACA,O;;AAEA,6D;AACA,6C;;AAEA,6C;AACA,0C;AACA,4C;AACA,oD;AACA,kD;;AAEA,8B;AACA,6F;;AAEA,sD;;AAEA,2C;AACA,2B;AACA,wD;;AAEA,8C;AACA,8D;AACA,8B;AACA,4E;AACA,oD;AACA,a;AACA,W;AACA,W;AACA,S;AACA,O;;AAEA,uE;AACA,uC;AACA,yD;AACA,6D;AACA,+B;AACA,iB;;AAEA,6D;AACA,0C;AACA,wB;AACA,wE;AACA,2C;AACA,S;AACA,O;AACA,K;;AAEA,wE;AACA,yE;AACA,0D;AACA,uE;AACA,sC;AACA,gF;AACA,wC;AACA,gD;AACA,0D;AACA,S;AACA,O;AACA,G;AACA,E;;AAEA,mE;AACA,qC;AACA,wE;AACA,+B;AACA,iC;AACA,4B;AACA,W;AACA,4E;AACA,gC;AACA,gF;AACA,sC;AACA,gE;AACA,yC;AACA,kB;AACA,oC;AACA,sB;AACA,oB;AACA,e;AACA,oB;;AAEA,gC;;AAEA,uB;AACA,iB;AACA,qE;AACA,mB;AACA,yC;AACA,qB;AACA,M;;AAEA,kB;AACA,sC;AACA,sB;AACA,4C;AACA,K;;AAEA,+C;AACA,+C;AACA,K;AACA,6C;AACA,mD;AACA,K;AACA,oE;AACA,+C;AACA,K;;AAEA,0E;AACA,4E;AACA,0B;AACA,iC;AACA,8B;AACA,yB;AACA,yE;AACA,gF;AACA,yE;AACA,S;AACA,qB;AACA,G;;AAEA,4E;AACA,6D;AACA,gE;AACA,4B;AACA,kD;AACA,4E;AACA,4C;AACA,O;AACA,K;AACA,qC;;AAEA,mE;;AAEA,6C;AACA,0D;AACA,iB;AACA,yE;AACA,gF;AACA,gF;AACA,6E;AACA,+E;AACA,0B;AACA,I;AACA,gF;AACA,6E;AACA,gF;AACA,4E;AACA,4E;AACA,6E;AACA,gB;AACA,2E;AACA,sE;AACA,oD;AACA,+C;AACA,gE;AACA,O;AACA,S;AACA,gF;AACA,iB;AACA,kC;AACA,+E;AACA,iB;AACA,qC;AACA,gB;AACA,K;AACA,G;;AAEA,6E;AACA,iE;AACA,a;AACA,S;AACA,kC;AACA,0D;AACA,iB;AACA,qC;AACA,gB;AACA,K;AACA,G;;AAEA,oE;AACA,yE;AACA,iB;AACA,a;AACA,qC;AACA,gC;AACA,wD;AACA,G;AACA,yD;AACA,6B;AACA,uB;AACA,a;AACA,E;;AAEA,0C;AACA,gC;AACA,E;;AAEA,qD;AACA,sB;AACA,2C;AACA,qC;AACA,kC;AACA,6E;AACA,8E;AACA,+E;AACA,+E;AACA,c;AACA,kD;AACA,K;AACA,oB;AACA,E;;;AAGA,0E;AACA,uD;AACA,oE;AACA,qE;AACA,0C;AACA,kB;AACA,wB;AACA,uB;;AAEA,4C;AACA,4E;AACA,sC;AACA,O;AACA,K;;AAEA,kD;AACA,gF;AACA,0E;AACA,yC;AACA,yC;AACA,iC;AACA,qD;AACA,kC;AACA,kD;AACA,iC;AACA,2C;AACA,W;AACA,Y;AACA,0C;AACA,sC;AACA,oC;AACA,4B;AACA,oC;AACA,c;AACA,iB;AACA,4C;AACA,U;AACA,S;AACA,uB;AACA,gF;AACA,O;AACA,K;;AAEA,iE;AACA,E;;AAEA,kE;AACA,0B;AACA,kB;AACA,yC;AACA,qB;AACA,8E;AACA,+B;AACA,gE;AACA,0C;AACA,K;;AAEA,mB;AACA,E;;AAEA,iE;AACA,sB;AACA,kB;;AAEA,2B;;AAEA,yB;AACA,qD;AACA,qE;AACA,6E;AACA,yB;AACA,M;AACA,U;AACA,qB;AACA,qD;AACA,kD;AACA,iD;;AAEA,uB;AACA,4B;;AAEA,gE;;AAEA,6E;AACA,qC;AACA,mC;AACA,4C;AACA,qC;AACA,O;;AAEA,8D;AACA,8B;AACA,+C;AACA,kD;AACA,8B;;AAEA,qD;AACA,sC;AACA,6C;AACA,6D;AACA,6C;AACA,gC;AACA,yD;AACA,0D;;AAEA,4B;AACA,gF;;AAEA,mC;AACA,8B;AACA,yD;AACA,iF;AACA,sE;AACA,sE;AACA,0C;AACA,6B;AACA,gH;AACA,oB;AACA,8C;AACA,iE;AACA,8C;AACA,0G;AACA,a;AACA,kB;AACA,oC;AACA,kE;AACA,0D;AACA,iG;AACA,W;AACA,gB;AACA,8B;AACA,mG;AACA,wD;;AAEA,mC;AACA,8B;AACA,gC;AACA,2C;AACA,6E;AACA,kB;AACA,oC;AACA,8D;AACA,4E;AACA,4C;AACA,kF;AACA,kH;AACA,mF;AACA,W;AACA,S;AACA,S;;AAEA,kB;AACA,M;;AAEA,sE;AACA,8B;;AAEA,8B;;AAEA,yD;AACA,4D;AACA,+B;AACA,kC;AACA,iB;AACA,S;;AAEA,yC;AACA,yC;AACA,2D;;AAEA,wE;AACA,qB;AACA,iC;AACA,mB;;AAEA,2C;AACA,0D;;AAEA,4B;AACA,8F;AACA,+B;AACA,2B;AACA,mB;AACA,W;;AAEA,gC;AACA,uE;AACA,0D;AACA,qC;AACA,2B;AACA,mB;AACA,W;;AAEA,0C;AACA,gB;AACA,0D;AACA,uD;;AAEA,8B;AACA,4C;AACA,iE;AACA,oE;;AAEA,yC;AACA,S;AACA,S;;AAEA,kB;AACA,M;;AAEA,mE;AACA,wC;AACA,gD;;AAEA,mB;AACA,qC;AACA,+B;AACA,S;;AAEA,iB;AACA,M;AACA,G;;AAEA,yB;AACA,E;;;;;;;;;;;;;;;;;;;ACngBA,2B;;AAEA,4C;;AAEA,gF;AACA,W;AACA,gF;;AAEA,wE;AACA,+E;AACA,mE;AACA,4C;AACA,8C;AACA,2E;AACA,yE;AACA,gD;AACA,kB;AACA,0B;;AAEA,8B;;AAEA,mE;AACA,0B;AACA,+C;AACA,8B;;AAEA,wD;AACA,yB;;AAEA,gF;AACA,8E;AACA,2E;AACA,gF;AACA,+E;AACA,8E;AACA,I;AACA,+E;AACA,uB;AACA,E;;AAEA,6E;AACA,kB;;AAEA,mD;;AAEA,8D;AACA,gE;AACA,G;;AAEA,sD;AACA,8C;AACA,U;AACA,sE;AACA,gE;AACA,8D;AACA,yC;AACA,K;AACA,G;;AAEA,yD;AACA,+D;AACA,E;;;;AAIA,mF;AACA,kB;AACA,0D;AACA,E;;AAEA,6B;AACA,mD;AACA,mD;AACA,sC;AACA,kB;;AAEA,sB;AACA,mC;;AAEA,2D;;AAEA,yC;AACA,uC;;AAEA,sC;AACA,6D;AACA,E;;AAEA,4D;AACA,mD;AACA,kB;AACA,0B;AACA,yB;AACA,2C;;AAEA,0C;AACA,mC;AACA,G;AACA,iE;AACA,E;;AAEA,6E;AACA,wB;AACA,kB;;AAEA,kD;AACA,W;AACA,wC;AACA,G;AACA,0C;AACA,gB;AACA,G;AACA,mD;AACA,gB;AACA,G;AACA,4C;AACA,E;;AAEA,mB;AACA,+E;AACA,0E;AACA,8D;AACA,8E;AACA,gE;AACA,wD;AACA,yC;AACA,kB;AACA,kC;AACA,kD;AACA,sB;AACA,iD;AACA,4C;AACA,e;AACA,M;AACA,uD;AACA,gC;AACA,K;AACA,c;;AAEA,0C;;AAEA,4E;AACA,4E;AACA,8E;AACA,8E;AACA,gF;AACA,2E;AACA,wC;AACA,8B;;AAEA,2D;;AAEA,uB;AACA,mC;AACA,G;;AAEA,6C;AACA,mE;;AAEA,0E;AACA,6E;AACA,4D;AACA,M;AACA,8E;AACA,2E;AACA,gF;AACA,4E;AACA,2E;AACA,4E;AACA,8E;AACA,8E;AACA,oD;AACA,6D;AACA,wE;AACA,iE;AACA,O;AACA,6E;AACA,e;AACA,K;AACA,K;;AAEA,4C;AACA,iE;AACA,mD;AACA,uC;AACA,K;;AAEA,6B;AACA,8B;AACA,G;;AAEA,yB;AACA,iD;AACA,G;;AAEA,+B;AACA,8C;AACA,Y;AACA,kC;AACA,oC;AACA,6C;AACA,gC;AACA,M;AACA,I;;AAEA,uD;;AAEA,uB;AACA,2B;AACA,wB;AACA,+E;AACA,iB;AACA,iC;;AAEA,gC;;AAEA,iC;AACA,kC;AACA,K;;AAEA,8E;;AAEA,iC;AACA,uD;AACA,wD;AACA,oE;AACA,Y;AACA,uD;AACA,+E;AACA,8E;AACA,sB;AACA,mD;AACA,S;AACA,K;AACA,G;;AAEA,mC;AACA,kB;AACA,0C;AACA,G;;AAEA,sD;AACA,E;;AAEA,qD;AACA,6B;AACA,iC;AACA,U;AACA,E;;AAEA,Y;AACA,sB;AACA,wB;AACA,uB;AACA,I;AACA,gE;AACA,gC;AACA,kB;;AAEA,2B;AACA,+B;AACA,8B;;AAEA,sD;AACA,8C;AACA,iC;AACA,6B;AACA,+B;AACA,mC;AACA,K;AACA,K;;AAEA,uC;AACA,qE;;AAEA,4D;;AAEA,qB;AACA,wB;AACA,uD;AACA,8D;AACA,+B;AACA,oC;AACA,6B;AACA,uC;AACA,K;AACA,K;;AAEA,yB;AACA,mD;AACA,G;AACA,U;AACA,mB;AACA,2B;AACA,kC;AACA,I;AACA,E;;AAEA,gF;AACA,c;AACA,gF;;AAEA,kE;AACA,kB;;AAEA,sB;AACA,6B;AACA,qB;AACA,4C;;AAEA,mB;AACA,8E;AACA,oE;AACA,2D;AACA,yB;AACA,4D;AACA,kC;AACA,uC;AACA,E;;AAEA,kD;AACA,kC;AACA,oB;;AAEA,wB;AACA,8C;AACA,a;AACA,K;AACA,iC;AACA,I;AACA,wC;AACA,oB;;AAEA,mD;AACA,gD;AACA,a;AACA,+C;AACA,+E;AACA,K;;AAEA,yD;AACA,I;;AAEA,gC;AACA,oB;AACA,4B;AACA,8E;AACA,qC;AACA,G;AACA,G;;AAEA,gF;AACA,a;AACA,gF;;AAEA,wB;AACA,yD;AACA,M;AACA,sD;AACA,8D;AACA,kB;AACA,sB;AACA,sC;AACA,G;;AAEA,2E;AACA,8D;AACA,uD;AACA,yB;AACA,kB;AACA,M;;AAEA,E;;AAEA,qE;AACA,kB;AACA,0B;AACA,4E;AACA,4C;AACA,E;;;AAGA,8D;AACA,0C;AACA,kB;AACA,mD;;AAEA,uC;AACA,iE;AACA,kC;AACA,G;;AAEA,6D;AACA,oD;AACA,6E;AACA,8D;AACA,2C;AACA,kC;AACA,oB;;AAEA,6E;AACA,e;AACA,iE;AACA,8D;AACA,uC;AACA,oB;AACA,O;;AAEA,yC;AACA,mB;AACA,K;;AAEA,4C;AACA,4D;AACA,K;;AAEA,oD;AACA,qE;AACA,K;;AAEA,iF;AACA,+E;AACA,oB;AACA,4C;AACA,oE;AACA,yD;AACA,oB;AACA,kE;AACA,+D;AACA,wC;AACA,qB;AACA,O;AACA,K;;AAEA,iF;AACA,4B;AACA,6E;AACA,mB;;AAEA,sD;AACA,yC;AACA,8E;AACA,4E;AACA,a;AACA,e;AACA,mB;;AAEA,4D;AACA,gF;AACA,+E;AACA,iC;AACA,2D;AACA,K;;AAEA,E;;AAEA,0E;AACA,8E;AACA,2C;AACA,kC;AACA,kB;AACA,uC;AACA,gC;AACA,wB;AACA,E;;;;;;;;;;;;;;;;;;;AChdA,gF;AACA,kB;AACA,gF;AACA,0E;AACA,8E;AACA,E;AACA,wE;AACA,gF;AACA,8D;AACA,E;AACA,2E;AACA,4E;AACA,+E;AACA,8B;AACA,6E;AACA,gB;AACA,oD;AACA,kB;;AAEA,a;AACA,4B;AACA,gC;AACA,8C;AACA,U;AACA,iC;AACA,mC;AACA,0C;AACA,G;AACA,E;;AAEA,oE;AACA,kB;AACA,6D;AACA,yC;AACA,E;;AAEA,gF;AACA,kB;AACA,6C;AACA,E;;AAEA,qD;AACA,gE;AACA,kB;;AAEA,yB;AACA,gB;AACA,G;;AAEA,2D;AACA,4D;AACA,8E;AACA,S;AACA,2E;AACA,kB;AACA,mD;AACA,wC;AACA,mE;;AAEA,uE;AACA,2E;AACA,8E;AACA,qC;AACA,oC;AACA,2D;AACA,kE;AACA,0C;AACA,mD;AACA,K;AACA,G;AACA,iB;AACA,E;;AAEA,+E;AACA,kB;AACA,yC;AACA,6C;;AAEA,sB;AACA,qC;AACA,qC;AACA,qB;AACA,kB;AACA,K;AACA,I;;AAEA,mC;AACA,c;AACA,W;AACA,uC;AACA,E;;AAEA,0C;AACA,mE;AACA,kB;AACA,qD;AACA,kD;AACA,qD;AACA,O;AACA,K;AACA,E;;AAEA,sE;AACA,mE;AACA,mC;AACA,kB;;AAEA,uB;;AAEA,yC;AACA,wD;AACA,wB;AACA,mB;AACA,K;AACA,K;;AAEA,mB;AACA,E;;AAEA,0E;AACA,kB;AACA,0B;;AAEA,gB;;AAEA,0B;AACA,oE;AACA,K;;AAEA,c;;AAEA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACpIA,+B;;AAEA,qD;AACA,kB;AACA,4B;AACA,wC;AACA,uC;AACA,4B;AACA,iC;AACA,2C;AACA,gD;AACA,uC;AACA,4B;AACA,0D;AACA,0C;AACA,8D;AACA,uC;AACA,0C;AACA,oB;AACA,E;;AAEA,mC;AACA,iD;AACA,oB;AACA,mB;AACA,kB;;AAEA,0B;AACA,2D;AACA,oD;AACA,4C;AACA,kB;;AAEA,yB;AACA,sC;AACA,+C;;AAEA,yD;AACA,iB;AACA,gF;AACA,oE;AACA,+B;AACA,6D;AACA,2C;AACA,oD;AACA,uB;AACA,wC;AACA,oE;AACA,kB;AACA,K;;AAEA,qE;AACA,uB;AACA,0D;AACA,yE;AACA,sC;AACA,6D;AACA,S;AACA,2C;AACA,iC;AACA,oE;AACA,yC;AACA,0C;AACA,sE;AACA,qD;AACA,oE;AACA,oE;AACA,4E;AACA,wC;AACA,gE;AACA,O;AACA,K;AACA,gB;AACA,I;AACA,+C;AACA,oB;;AAEA,0D;AACA,wD;AACA,kB;AACA,K;;AAEA,yB;;AAEA,yD;AACA,kE;AACA,kB;AACA,K;;AAEA,2E;AACA,sD;AACA,qF;AACA,kC;AACA,wE;AACA,gB;AACA,O;;AAEA,sC;AACA,+B;AACA,8D;AACA,uC;AACA,iC;AACA,6D;AACA,kB;AACA,gD;AACA,kE;AACA,+D;AACA,Y;AACA,sC;AACA,oD;AACA,0C;AACA,K;;AAEA,gB;AACA,I;AACA,qC;AACA,oB;;AAEA,mB;AACA,kB;AACA,4C;AACA,8C;;AAEA,yB;;AAEA,sE;AACA,gC;AACA,4E;AACA,2D;AACA,+D;AACA,K;;AAEA,mD;AACA,yD;AACA,kE;AACA,uC;;AAEA,yE;AACA,e;AACA,oD;AACA,+C;AACA,gE;AACA,O;AACA,iD;AACA,8D;AACA,O;;AAEA,gB;AACA,I;AACA,6E;AACA,Y;AACA,6C;AACA,oB;AACA,oC;AACA,mC;AACA,mE;AACA,0B;AACA,I;AACA,wB;AACA,oB;AACA,4D;AACA,I;AACA,mC;AACA,oB;AACA,8C;AACA,2D;AACA,2D;AACA,2B;AACA,I;AACA,8B;AACA,oB;AACA,kF;AACA,I;AACA,+C;AACA,oB;AACA,0D;AACA,kB;AACA,yB;AACA,gC;AACA,I;AACA,uB;AACA,oB;AACA,wE;AACA,oG;AACA,iC;AACA,O;AACA,iB;AACA,I;AACA,qD;AACA,oB;AACA,gE;AACA,4C;AACA,gD;AACA,oB;AACA,sC;AACA,oB;AACA,I;AACA,6D;AACA,oB;AACA,kF;AACA,wD;AACA,kB;AACA,G;AACA,G;;AAEA,8E;AACA,gF;AACA,0E;AACA,yB;AACA,iC;AACA,wD;AACA,E;;AAEA,4E;AACA,2C;AACA,sC;AACA,4C;AACA,wC;AACA,oB;AACA,gC;AACA,E;;AAEA,0E;AACA,oD;AACA,wC;AACA,uC;AACA,+C;AACA,E;;AAEA,mD;AACA,0D;AACA,+C;AACA,6B;;AAEA,qD;AACA,yE;AACA,oB;AACA,G;;AAEA,6E;AACA,8E;AACA,oE;AACA,4D;AACA,sC;AACA,gC;AACA,E;;;;;;;;;;;;;;;;;;;ACrPA,6B;AACA,kB;AACA,uC;AACA,sC;AACA,wB;AACA,kC;AACA,2C;AACA,Y;AACA,6B;;AAEA,a;AACA,I;AACA,e;AACA,4C;AACA,+B;AACA,K;;AAEA,4B;AACA,mB;AACA,E;;AAEA,mC;AACA,+B;AACA,oB;AACA,yB;AACA,6B;AACA,2B;AACA,I;AACA,oB;AACA,oB;;AAEA,qB;AACA,4C;;AAEA,uC;AACA,2B;AACA,I;AACA,oB;AACA,oB;;AAEA,qB;AACA,4C;;AAEA,uC;AACA,+B;;AAEA,2B;AACA,0B;;AAEA,gB;AACA,I;AACA,sB;AACA,oB;AACA,8B;AACA,I;AACA,qB;AACA,oB;AACA,6B;AACA,G;AACA,G","sourcesContent":["// Copied from archinfo.matches() in tools/\nvar archMatches = function (arch, baseArch) {\n  return arch.substr(0, baseArch.length) === baseArch &&\n    (arch.length === baseArch.length ||\n     arch.substr(baseArch.length, 1) === \".\");\n};\n\nConstraintSolver = {};\n\n// catalog is a catalog.Catalog object. We have to pass this in because\n// we're in a package and can't require('release.js'). If this code\n// moves to the tool, or if all of the tool code moves to a star, we\n// should get cat from release.current.catalog rather than passing it\n// in.\nConstraintSolver.PackagesResolver = function (catalog, options) {\n  var self = this;\n\n  options = options || {};\n\n  self.catalog = catalog;\n\n  // The main resolver\n  self.resolver = new ConstraintSolver.Resolver({\n    nudge: options.nudge\n  });\n\n  self._packageInfoLoadQueue = [];\n  self._packagesEverEnqueued = {};\n  self._loadingPackageInfo = false;\n};\n\nConstraintSolver.PackagesResolver.prototype._ensurePackageInfoLoaded = function (\n    packageName) {\n  var self = this;\n  if (_.has(self._packagesEverEnqueued, packageName))\n    return;\n  self._packagesEverEnqueued[packageName] = true;\n  self._packageInfoLoadQueue.push(packageName);\n\n  // Is there already an instance of _ensurePackageInfoLoaded up the stack?\n  // Great, it'll get this.\n  // XXX does this work correctly with multiple fibers?\n  if (self._loadingPackageInfo)\n    return;\n\n  self._loadingPackageInfo = true;\n  try {\n    while (self._packageInfoLoadQueue.length) {\n      var nextPackageName = self._packageInfoLoadQueue.shift();\n      self._loadPackageInfo(nextPackageName);\n    }\n  } finally {\n    self._loadingPackageInfo = false;\n  }\n};\n\nConstraintSolver.PackagesResolver.prototype._loadPackageInfo = function (\n    packageName) {\n  var self = this;\n\n  // XXX in theory there might be different archs but in practice they are\n  // always \"os\", \"web.browser\" and \"web.cordova\". Fix this once we\n  // actually have different archs used.\n  var allArchs = [\"os\", \"web.browser\", \"web.cordova\"];\n\n  // We rely on sortedness in the constraint solver, since one of the cost\n  // functions wants to be able to quickly find the earliest or latest version.\n  var sortedVersions = self.catalog.getSortedVersions(packageName);\n  _.each(sortedVersions, function (version) {\n    var versionDef = self.catalog.getVersion(packageName, version);\n\n    var unibuilds = {};\n\n    _.each(allArchs, function (arch) {\n      var unitName = packageName + \"#\" + arch;\n      unibuilds[unitName] = new ConstraintSolver.UnitVersion(\n        unitName, version, versionDef.earliestCompatibleVersion);\n      self.resolver.addUnitVersion(unibuilds[unitName]);\n    });\n\n    _.each(versionDef.dependencies, function (dep, depName) {\n      self._ensurePackageInfoLoaded(depName);\n\n      _.each(dep.references, function (ref) {\n        _.each(allArchs, function (arch) {\n          if (archMatches(arch, ref.arch)) {\n            var unitName = packageName + \"#\" + arch;\n            var unitVersion = unibuilds[unitName];\n\n            if (! unitVersion)\n              throw new Error(\"A non-standard arch \" + arch + \" for package \" + packageName);\n\n            var targetUnitName = depName + \"#\" + arch;\n\n            // Add the dependency if needed\n            if (! ref.weak)\n              unitVersion.addDependency(targetUnitName);\n\n            // Add a constraint if such exists\n            if (dep.constraint && dep.constraint !== \"none\") {\n              var constraint =\n                self.resolver.getConstraint(targetUnitName, dep.constraint);\n              unitVersion.addConstraint(constraint);\n            }\n          }\n        });\n      });\n    });\n\n    // Every unibuild implies that if it is picked, other unibuilds are\n    // constrained to the same version.\n    _.each(unibuilds, function (unibuild, unibuildName) {\n      _.each(unibuilds, function (other, otherUnibuildName) {\n        if (unibuild === other)\n          return;\n\n        // Constraint is the exact same version of a unibuild\n        var constraintStr = \"=\" + version;\n        var constraint =\n          self.resolver.getConstraint(otherUnibuildName, constraintStr);\n        unibuild.addConstraint(constraint);\n      });\n    });\n  });\n\n  // We need to be aware of the earliestCompatibleVersion values for any\n  // packages that are overridden by local packages, in order to evaluate\n  // 'compatible-with' constraints that name that version.\n  // (Some of the test fixtures don't bother to implement this method.)\n  if (self.catalog.getForgottenECVs) {\n    _.each(self.catalog.getForgottenECVs(packageName), function (ecv, version) {\n      _.each(allArchs, function (arch) {\n        var unitName = packageName + '#' + arch;\n        self.resolver.addExtraECV(unitName, version, ecv);\n      });\n    });\n  }\n};\n\n// dependencies - an array of string names of packages (not slices)\n// constraints - an array of objects:\n//  (almost, but not quite, what PackageVersion.parseConstraint returns)\n//  - packageName - string name\n//  - version - string constraint\n//  - type - constraint type\n// options:\n//  - upgrade - list of dependencies for which upgrade is prioritized higher\n//  than keeping the old version\n//  - previousSolution - mapping from package name to a version that was used in\n//  the previous constraint solver run\nConstraintSolver.PackagesResolver.prototype.resolve = function (\n    dependencies, constraints, options) {\n  var self = this;\n  // clone because we mutate options\n  options = _.extend({\n    _testing: false,\n    upgrade: []\n  }, options || {});\n\n  check(dependencies, [String]);\n\n  check(constraints, [{\n    name: String,\n    constraintString: Match.Optional(Match.OneOf(String, undefined)),\n    constraints: [{\n      version: Match.OneOf(String, null),\n      type: String }]\n  }]);\n\n  check(options, {\n    _testing: Match.Optional(Boolean),\n    upgrade: [String],\n    previousSolution: Match.Optional(Object)\n  });\n\n  _.each(dependencies, function (packageName) {\n    self._ensurePackageInfoLoaded(packageName);\n  });\n  _.each(constraints, function (constraint) {\n    self._ensurePackageInfoLoaded(constraint.name);\n  });\n  _.each(options.previousSolution, function (version, packageName) {\n    self._ensurePackageInfoLoaded(packageName);\n  });\n\n  // XXX glasser and ekate added this filter to strip some undefineds that\n  // were causing crashes, but maybe the real answer is that there shouldn't\n  // have been undefineds?\n  if (options.previousSolution) {\n    options.previousSolution =\n      _.filter(_.flatten(\n        _.map(options.previousSolution, function (version, packageName) {\n      return _.map(self._unibuildsForPackage(packageName), function (unitName) {\n        return self.resolver._unitsVersionsMap[unitName + \"@\" + version];\n      });\n    })), _.identity);\n  }\n\n  // split every package name to one or more archs belonging to that package\n  // ([\"foobar\"] => [\"foobar#os\", \"foobar#web.browser\", ...])\n  // XXX for now just hardcode in all of the known architectures\n  var upgradeUnibuilds = {};\n  _.each(options.upgrade, function (packageName) {\n    _.each(self._unibuildsForPackage(packageName), function (unibuildName) {\n      upgradeUnibuilds[unibuildName] = true;\n    });\n  });\n  options.upgrade = upgradeUnibuilds;\n\n  var dc = self._splitDepsToConstraints(dependencies, constraints);\n\n  options.rootDependencies = dc.dependencies;\n  var resolverOptions = self._getResolverOptions(options);\n  var res = null;\n  // If a previous solution existed, try resolving with additional (weak)\n  // equality constraints on all the versions from the previous solution (except\n  // those we've explicitly been asked to update). If it's possible to solve the\n  // constraints without changing any of the previous versions (though we may\n  // add more choices in addition, or remove some now-unnecessary choices) then\n  // that's our first try.\n  //\n  // If we're intentionally trying to upgrade some or all packages, we just skip\n  // this step. We used to try to do this step but just leaving off pins from\n  // the packages we're trying to upgrade, but this tended to not lead to actual\n  // upgrades since we were still pinning things that the to-upgrade package\n  // depended on.  (We still use the specific contents of options.upgrade to\n  // guide which things are encouraged to be upgraded vs stay the same in the\n  // heuristic.)\n  if (!_.isEmpty(options.previousSolution) && _.isEmpty(options.upgrade)) {\n    var constraintsWithPreviousSolutionLock = _.clone(dc.constraints);\n    _.each(options.previousSolution, function (uv) {\n      constraintsWithPreviousSolutionLock.push(\n        self.resolver.getConstraint(uv.name, '=' + uv.version));\n    });\n    try {\n      // Try running the resolver. If it fails to resolve, that's OK, we'll keep\n      // working.\n      res = self.resolver.resolve(\n        dc.dependencies, constraintsWithPreviousSolutionLock, resolverOptions);\n    } catch (e) {\n      if (!(e.constraintSolverError))\n        throw e;\n    }\n  }\n\n  // Either we didn't have a previous solution, or it doesn't work. Try again\n  // without locking in the previous solution as strict equality.\n  if (!res) {\n    try {\n      res = self.resolver.resolve(\n        dc.dependencies, dc.constraints, resolverOptions);\n    } catch (e) {\n      if (!(e.constraintSolverError))\n        throw e;\n    }\n  }\n\n  // As a last-ditch effort, let's take a look at all the prerelease\n  // versions. Is it possible that a pre-release version will satisfy our\n  // constraints?\n  if (!res) {\n    resolverOptions[\"useRCs\"] = true;\n    res = self.resolver.resolve(\n      dc.dependencies, dc.constraints, resolverOptions);\n  }\n  var ret = { answer:  resolverResultToPackageMap(res) };\n  if (resolverOptions.useRCs)\n    ret.usedRCs = true;\n  return ret;\n};\n\nvar removeUnibuild = function (unitName) {\n  return unitName.split('#')[0];\n};\n\nvar resolverResultToPackageMap = function (choices) {\n  var packageMap = {};\n  mori.each(choices, function (nameAndUv) {\n    var name = mori.first(nameAndUv);\n    var uv = mori.last(nameAndUv);\n    // Since we don't yet define the interface for a an app to depend only on\n    // certain unibuilds of the packages (like only web unibuilds) and we know\n    // that each unibuild weakly depends on other sibling unibuilds of the same\n    // version, we can safely output the whole package for each unibuild in the\n    // result.\n    packageMap[removeUnibuild(name)] = uv.version;\n  });\n  return packageMap;\n};\n\n\n// takes dependencies and constraints and rewrites the names from \"foo\" to\n// \"foo#os\" and \"foo#web.browser\" and \"foo#web.cordova\"\n// XXX right now creates a dependency for every unibuild it can find\nConstraintSolver.PackagesResolver.prototype._splitDepsToConstraints =\n  function (inputDeps, inputConstraints) {\n  var self = this;\n  var dependencies = [];\n  var constraints = [];\n\n  _.each(inputDeps, function (packageName) {\n    _.each(self._unibuildsForPackage(packageName), function (unibuildName) {\n      dependencies.push(unibuildName);\n    });\n  });\n\n  _.each(inputConstraints, function (constraint) {\n    _.each(self._unibuildsForPackage(constraint.name), function (unibuildName) {\n      //XXX: This is kind of dumb -- we make this up, so we can reparse it\n      //later. Todo: clean this up a bit.\n      if (!constraint.constraintString) {\n        var constraintArray = [];\n        _.each(constraint.constraints, function (c) {\n          if (c.type == \"exact\") {\n            constraintArray.push(\"+\" + c.version);\n          } else if (c.version) {\n            constraintArray.push(c.version)\n          }\n         });\n        if (!_.isEmpty(constraintArray)) {\n         constraint.constraintString =\n           _.reduce(constraintArray,\n            function(x, y) {\n              return x + \" || \" + y;\n           });\n         } else {\n           constraint.constraintString = \"\";\n         }\n        }\n      constraints.push(\n        self.resolver.getConstraint(unibuildName, constraint.constraintString));\n    });\n  });\n\n return { dependencies: dependencies, constraints: constraints };\n};\n\nConstraintSolver.PackagesResolver.prototype._unibuildsForPackage =\n  function (packageName) {\n  var self = this;\n  var unibuildPrefix = packageName + \"#\";\n  var unibuilds = [];\n  // XXX hardcode all common architectures assuming that every package has the\n  // same set of architectures.\n  _.each([\"os\", \"web.browser\", \"web.cordova\"], function (arch) {\n    unibuilds.push(unibuildPrefix + arch);\n  });\n\n  return unibuilds;\n};\n\nConstraintSolver.PackagesResolver.prototype._getResolverOptions =\n  function (options) {\n  var self = this;\n\n  var resolverOptions = {};\n\n  if (options._testing) {\n    resolverOptions.costFunction = function (state) {\n      return mori.reduce(mori.sum, 0, mori.map(function (nameAndUv) {\n        return PackageVersion.versionMagnitude(mori.last(nameAndUv).version);\n      }, state.choices));\n    };\n  } else {\n    // Poorman's enum\n    var VMAJOR = 0, MAJOR = 1, MEDIUM = 2, MINOR = 3;\n    var rootDeps = options.rootDependencies || [];\n    var prevSol = options.previousSolution || [];\n\n    var isRootDep = {};\n    var prevSolMapping = {};\n\n    _.each(rootDeps, function (dep) { isRootDep[dep] = true; });\n\n    // if the upgrade is preferred over preserving previous solution, pretend\n    // there are no previous solution\n    _.each(prevSol, function (uv) {\n      if (! _.has(options.upgrade, uv.name))\n        prevSolMapping[uv.name] = uv;\n    });\n\n    resolverOptions.costFunction = function (state, options) {\n      options = options || {};\n      // very major, major, medium, minor costs\n      // XXX maybe these can be calculated lazily?\n      var cost = [0, 0, 0, 0];\n\n      mori.each(state.choices, function (nameAndUv) {\n        var uv = mori.last(nameAndUv);\n        if (_.has(prevSolMapping, uv.name)) {\n          // The package was present in the previous solution\n          var prev = prevSolMapping[uv.name];\n          var versionsDistance =\n            PackageVersion.versionMagnitude(uv.version) -\n            PackageVersion.versionMagnitude(prev.version);\n\n          var isCompatible =\n                prev.earliestCompatibleVersion === uv.earliestCompatibleVersion;\n\n          if (isRootDep[uv.name]) {\n            // root dependency\n            if (versionsDistance < 0 || ! isCompatible) {\n              // the new pick is older or is incompatible with the prev. solution\n              // i.e. can have breaking changes, prefer not to do this\n              // XXX in fact we want to avoid downgrades to the direct\n              // dependencies at all cost.\n              cost[VMAJOR]++;\n              options.debug && console.log(\"root & *not* compatible: \", uv.name, prev.version, \"=>\", uv.version)\n            } else {\n              // compatible but possibly newer\n              // prefer the version closest to the older solution\n              cost[MAJOR] += versionsDistance;\n              options.debug && console.log(\"root & compatible: \", uv.name, prev.version, \"=>\", uv.version)\n            }\n          } else {\n            // transitive dependency\n            // prefer to have less changed transitive dependencies\n            cost[MINOR] += versionsDistance === 0 ? 0 : 1;\n            options.debug && console.log(\"transitive: \", uv.name, prev.version, \"=>\", uv.version)\n          }\n        } else {\n          var latestDistance =\n            PackageVersion.versionMagnitude(_.last(self.resolver.unitsVersions[uv.name]).version) -\n            PackageVersion.versionMagnitude(uv.version);\n\n          if (isRootDep[uv.name]) {\n            // root dependency\n            // preferably latest\n            cost[MEDIUM] += latestDistance;\n            options.debug && console.log(\"root: \", uv.name, \"=>\", uv.version)\n          } else {\n            // transitive dependency\n            // prefarable earliest possible to be conservative\n            // How far is our choice from the most conservative version that\n            // also matches our constraints?\n            var minimal = state.constraints.getMinimalVersion(uv.name) || '0.0.0';\n            cost[MINOR] += PackageVersion.versionMagnitude(uv.version) - PackageVersion.versionMagnitude(minimal);\n            options.debug && console.log(\"transitive: \", uv.name, \"=>\", uv.version)\n          }\n        }\n      });\n\n      return cost;\n    };\n\n    resolverOptions.estimateCostFunction = function (state, options) {\n      options = options || {};\n\n      var cost = [0, 0, 0, 0];\n\n      state.eachDependency(function (dep, alternatives) {\n        // XXX don't try to estimate transitive dependencies\n        if (! isRootDep[dep]) {\n          cost[MINOR] += 10000000;\n          return;\n        }\n\n        if (_.has(prevSolMapping, dep)) {\n          var prev = prevSolMapping[dep];\n          var prevVersionMatches = state.isSatisfied(prev);\n\n          // if it matches, assume we would pick it and the cost doesn't\n          // increase\n          if (prevVersionMatches)\n            return;\n\n          // Get earliest matching version.\n          var earliestMatching = mori.first(alternatives);\n\n          var isCompatible =\n                prev.earliestCompatibleVersion === earliestMatching.earliestCompatibleVersion;\n          if (! isCompatible) {\n            cost[VMAJOR]++;\n            return;\n          }\n\n          var versionsDistance =\n            PackageVersion.versionMagnitude(earliestMatching.version) -\n            PackageVersion.versionMagnitude(prev.version);\n          if (versionsDistance < 0) {\n            cost[VMAJOR]++;\n            return;\n          }\n\n          cost[MAJOR] += versionsDistance;\n        } else {\n          var versions = self.resolver.unitsVersions[dep];\n          var latestMatching = mori.last(alternatives);\n\n          var latestDistance =\n            PackageVersion.versionMagnitude(\n              _.last(self.resolver.unitsVersions[dep]).version) -\n            PackageVersion.versionMagnitude(latestMatching.version);\n\n          cost[MEDIUM] += latestDistance;\n        }\n      });\n\n      return cost;\n    };\n\n    resolverOptions.combineCostFunction = function (costA, costB) {\n      if (costA.length !== costB.length)\n        throw new Error(\"Different cost types\");\n\n      var arr = [];\n      _.each(costA, function (l, i) {\n        arr.push(l + costB[i]);\n      });\n\n      return arr;\n    };\n  }\n\n  return resolverOptions;\n};\n","mori = Npm.require('mori');\n\nBREAK = {};  // used by our 'each' functions\n\n////////////////////////////////////////////////////////////////////////////////\n// Resolver\n////////////////////////////////////////////////////////////////////////////////\n\n// XXX the whole resolver heavily relies on these statements to be true:\n// - every unit version ever used was added to the resolver with addUnitVersion\n// - every constraint ever used was instantiated with getConstraint\n// - every constraint was added exactly once\n// - every unit version was added exactly once\n// - if two unit versions are the same, their refs point at the same object\n// - if two constraints are the same, their refs point at the same object\nConstraintSolver.Resolver = function (options) {\n  var self = this;\n  options = options || {};\n\n  self._nudge = options.nudge;\n\n  // Maps unit name string to a sorted array of version definitions\n  self.unitsVersions = {};\n  // Maps name@version string to a unit version\n  self._unitsVersionsMap = {};\n\n  // Refs to all constraints. Mapping String -> instance\n  self._constraints = {};\n\n  // Let's say that we that package P is available from source at version X.Y.Z.\n  // Then that's the only version that can actually be chosen by the resolver,\n  // and so it's the only version included as a UnitVersion.  But let's say\n  // another unit depends on it with a 'compatible-with' dependency \"@A.B.C\". We\n  // need to be able to figure out the earliestCompatibleVersion of A.B.C, even\n  // though A.B.C is not a valid (selectable) UnitVersion. We store them here.\n  //\n  // Maps String unitName -> String version -> String earliestCompatibleVersion\n  self._extraECVs = {};\n};\n\nConstraintSolver.Resolver.prototype.addUnitVersion = function (unitVersion) {\n  var self = this;\n\n  check(unitVersion, ConstraintSolver.UnitVersion);\n\n  if (_.has(self._unitsVersionsMap, unitVersion.toString())) {\n    throw Error(\"duplicate uv \" + unitVersion.toString() + \"?\");\n  }\n\n  if (! _.has(self.unitsVersions, unitVersion.name)) {\n    self.unitsVersions[unitVersion.name] = [];\n  } else {\n    var latest = _.last(self.unitsVersions[unitVersion.name]).version;\n    if (!PackageVersion.lessThan(latest, unitVersion.version)) {\n      throw Error(\"adding uv out of order: \" + latest + \" vs \"\n                  + unitVersion.version);\n    }\n  }\n\n  self.unitsVersions[unitVersion.name].push(unitVersion);\n  self._unitsVersionsMap[unitVersion.toString()] = unitVersion;\n};\n\n\n\nConstraintSolver.Resolver.prototype.getUnitVersion = function (unitName, version) {\n  var self = this;\n  return self._unitsVersionsMap[unitName + \"@\" + version];\n};\n\n// name - String - \"someUnit\"\n// versionConstraint - String - \"=1.2.3\" or \"2.1.0\"\nConstraintSolver.Resolver.prototype.getConstraint =\n  function (name, versionConstraint) {\n  var self = this;\n\n  check(name, String);\n  check(versionConstraint, String);\n\n  var idString = JSON.stringify([name, versionConstraint]);\n\n  if (_.has(self._constraints, idString))\n    return self._constraints[idString];\n\n  return self._constraints[idString] =\n    new ConstraintSolver.Constraint(name, versionConstraint);\n};\n\nConstraintSolver.Resolver.prototype.addExtraECV = function (\n    unitName, version, earliestCompatibleVersion) {\n  var self = this;\n  check(unitName, String);\n  check(version, String);\n  check(earliestCompatibleVersion, String);\n\n  if (!_.has(self._extraECVs, unitName)) {\n    self._extraECVs[unitName] = {};\n  }\n  self._extraECVs[unitName][version] = earliestCompatibleVersion;\n};\n\nConstraintSolver.Resolver.prototype.getEarliestCompatibleVersion = function (\n    unitName, version) {\n  var self = this;\n\n  var uv = self.getUnitVersion(unitName, version);\n  if (uv) {\n    return uv.earliestCompatibleVersion;\n  }\n  if (!_.has(self._extraECVs, unitName)) {\n    return null;\n  }\n  if (!_.has(self._extraECVs[unitName], version)) {\n    return null;\n  }\n  return self._extraECVs[unitName][version];\n};\n\n// options: Object:\n// - costFunction: function (state, options) - given a state evaluates its cost\n// - estimateCostFunction: function (state) - given a state, evaluates the\n// estimated cost of the best path from state to a final state\n// - combineCostFunction: function (cost, cost) - given two costs (obtained by\n// evaluating states with costFunction and estimateCostFunction)\nConstraintSolver.Resolver.prototype.resolve = function (\n    dependencies, constraints, options) {\n  var self = this;\n  constraints = constraints || [];\n  var choices = mori.hash_map();  // uv.name -> uv\n  options = _.extend({\n    costFunction: function (state) { return 0; },\n    estimateCostFunction: function (state) {\n      return 0;\n    },\n    combineCostFunction: function (cost, anotherCost) {\n      return cost + anotherCost;\n    }\n  }, options);\n\n  var resolveContext = new ResolveContext;\n\n  // Mapping that assigns every package an integer priority. We compute this\n  // dynamically and in the process of resolution we try to resolve packages\n  // with higher priority first. This helps the resolver a lot because if some\n  // package has a higher weight to the solution (like a direct dependency) or\n  // is more likely to break our solution in the future than others, it would be\n  // great to try out and evaluate all versions early in the decision tree.\n  // XXX this could go on ResolveContext\n  var resolutionPriority = {};\n\n  var startState = new ResolverState(self, resolveContext);\n\n  if (options.useRCs) {\n    resolveContext.useRCsOK = true;\n  }\n\n  _.each(constraints, function (constraint) {\n    startState = startState.addConstraint(constraint, mori.list());\n\n    // Keep track of any top-level constraints that mention a pre-release.\n    // These will be the only pre-release versions that count as \"reasonable\"\n    // for \"any-reasonable\" (ie, unconstrained) constraints.\n    //\n    // Why only top-level mentions, and not mentions we find while walking the\n    // graph? The constraint solver assumes that adding a constraint to the\n    // resolver state can't make previously impossible choices now possible.  If\n    // pre-releases mentioned anywhere worked, then applying the constraints\n    // \"any reasonable\" followed by \"1.2.3-rc1\" would result in \"1.2.3-rc1\"\n    // ruled first impossible and then possible again. That's no good, so we\n    // have to fix the meaning based on something at the start.  (We could try\n    // to apply our prerelease-avoidance tactics solely in the cost functions,\n    // but then it becomes a much less strict rule.)\n    if (constraint.version && /-/.test(constraint.version)) {\n      if (!_.has(resolveContext.topLevelPrereleases, constraint.name)) {\n        resolveContext.topLevelPrereleases[constraint.name] = {};\n      }\n      resolveContext.topLevelPrereleases[constraint.name][constraint.version]\n        = true;\n    }\n  });\n\n  _.each(dependencies, function (unitName) {\n    startState = startState.addDependency(unitName, mori.list());\n    // Direct dependencies start on higher priority\n    resolutionPriority[unitName] = 100;\n  });\n\n  if (startState.success()) {\n    return startState.choices;\n  }\n\n  if (startState.error) {\n    throwConstraintSolverError(startState.error);\n  }\n\n  var pq = new PriorityQueue();\n  var overallCostFunction = function (state) {\n    return [\n      options.combineCostFunction(\n        options.costFunction(state),\n        options.estimateCostFunction(state)),\n      -mori.count(state.choices)\n    ];\n  };\n\n  pq.push(startState, overallCostFunction(startState));\n\n  var someError = null;\n  var anySucceeded = false;\n  while (! pq.empty()) {\n    // Since we're in a CPU-bound loop, allow yielding or printing a message or\n    // something.\n    self._nudge && self._nudge();\n\n    var currentState = pq.pop();\n\n    if (currentState.success()) {\n      return currentState.choices;\n    }\n\n    var neighborsObj = self._stateNeighbors(currentState, resolutionPriority);\n\n    if (! neighborsObj.success) {\n      someError = someError || neighborsObj.failureMsg;\n      resolutionPriority[neighborsObj.conflictingUnit] =\n        (resolutionPriority[neighborsObj.conflictingUnit] || 0) + 1;\n    } else {\n      _.each(neighborsObj.neighbors, function (state) {\n        // We don't just return the first successful one we find, in case there\n        // are multiple successful states (we want to sort by cost function in\n        // that case).\n        pq.push(state, overallCostFunction(state));\n      });\n    }\n  }\n\n  // XXX should be much much better\n  if (someError) {\n    throwConstraintSolverError(someError);\n  }\n\n  throw new Error(\"ran out of states without error?\");\n};\n\nvar throwConstraintSolverError = function (message) {\n  var e = new Error(message);\n  e.constraintSolverError = true;\n  throw e;\n};\n\n// returns {\n//   success: Boolean,\n//   failureMsg: String,\n//   neighbors: [state]\n// }\nConstraintSolver.Resolver.prototype._stateNeighbors = function (\n    state, resolutionPriority) {\n  var self = this;\n\n  var candidateName = null;\n  var candidateVersions = null;\n  var currentNaughtiness = -1;\n\n  state.eachDependency(function (unitName, versions) {\n    var r = resolutionPriority[unitName] || 0;\n    if (r > currentNaughtiness) {\n      currentNaughtiness = r;\n      candidateName = unitName;\n      candidateVersions = versions;\n    }\n  });\n\n  if (mori.is_empty(candidateVersions))\n    throw Error(\"empty candidate set? should have detected earlier\");\n\n  var pathway = state.somePathwayForUnitName(candidateName);\n\n  var neighbors = [];\n  var firstError = null;\n  mori.each(candidateVersions, function (unitVersion) {\n    var neighborState = state.addChoice(unitVersion, pathway);\n    if (!neighborState.error) {\n      neighbors.push(neighborState);\n    } else if (!firstError) {\n      firstError = neighborState.error;\n    }\n  });\n\n  if (neighbors.length) {\n    return { success: true, neighbors: neighbors };\n  }\n  return {\n    success: false,\n    failureMsg: firstError,\n    conflictingUnit: candidateName\n  };\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// UnitVersion\n////////////////////////////////////////////////////////////////////////////////\n\nConstraintSolver.UnitVersion = function (name, unitVersion, ecv) {\n  var self = this;\n\n  check(name, String);\n  check(unitVersion, String);\n  check(ecv, String);\n  check(self, ConstraintSolver.UnitVersion);\n\n  self.name = name;\n  // Things with different build IDs should represent the same code, so ignore\n  // them. (Notably: depending on @=1.3.1 should allow 1.3.1+local!)\n  self.version = PackageVersion.removeBuildID(unitVersion);\n  self.dependencies = [];\n  self.constraints = new ConstraintSolver.ConstraintsList();\n  // a string in a form of \"1.2.0\"\n  self.earliestCompatibleVersion = ecv;\n};\n\n_.extend(ConstraintSolver.UnitVersion.prototype, {\n  addDependency: function (name) {\n    var self = this;\n\n    check(name, String);\n    if (_.contains(self.dependencies, name)) {\n      return;\n    }\n    self.dependencies.push(name);\n  },\n  addConstraint: function (constraint) {\n    var self = this;\n\n    check(constraint, ConstraintSolver.Constraint);\n    if (self.constraints.contains(constraint)) {\n      return;\n      // XXX may also throw if it is unexpected\n      throw new Error(\"Constraint already exists -- \" + constraint.toString());\n    }\n\n    self.constraints = self.constraints.push(constraint);\n  },\n\n  toString: function (options) {\n    var self = this;\n    options = options || {};\n    var name = options.removeUnibuild ? removeUnibuild(self.name) : self.name;\n    return name + \"@\" + self.version;\n  }\n});\n\n////////////////////////////////////////////////////////////////////////////////\n// Constraint\n////////////////////////////////////////////////////////////////////////////////\n\n// Can be called either:\n//    new PackageVersion.Constraint(\"packageA\", \"=2.1.0\")\n// or:\n//    new PackageVersion.Constraint(\"pacakgeA@=2.1.0\")\nConstraintSolver.Constraint = function (name, versionString) {\n  var self = this;\n  if (versionString) {\n    name = name + \"@\" + versionString;\n  }\n\n  // See comment in UnitVersion constructor. We want to strip out build IDs\n  // because the code they represent is considered equivalent.\n  _.extend(self, PackageVersion.parseConstraint(name, {\n    removeBuildIDs: true,\n    archesOK: true\n  }));\n\n};\n\nConstraintSolver.Constraint.prototype.toString = function (options) {\n  var self = this;\n  options = options || {};\n  var name = options.removeUnibuild ? removeUnibuild(self.name) : self.name;\n  return name + \"@\" + self.constraintString;\n};\n\n\nConstraintSolver.Constraint.prototype.isSatisfied = function (\n  candidateUV, resolver, resolveContext) {\n  var self = this;\n  check(candidateUV, ConstraintSolver.UnitVersion);\n\n  if (self.name !== candidateUV.name) {\n    throw Error(\"asking constraint on \" + self.name + \" about \" +\n                candidateUV.name);\n  }\n\n  return _.some(self.constraints, function (currConstraint) {\n     if (currConstraint.type === \"any-reasonable\") {\n      // Non-prerelease versions are always reasonable, and if we are OK with\n      // using RCs all the time, then they are reasonable too.\n      if (!/-/.test(candidateUV.version) ||\n          resolveContext.useRCsOK)\n        return true;\n\n      // Is it a pre-release version that was explicitly mentioned at the top\n      // level?\n      if (_.has(resolveContext.topLevelPrereleases, self.name) &&\n          _.has(resolveContext.topLevelPrereleases[self.name],\n                candidateUV.version)) {\n        return true;\n      }\n\n      // Otherwise, not this pre-release!\n      return false;\n    }\n\n    if (currConstraint.type === \"exactly\") {\n      return currConstraint.version === candidateUV.version;\n    }\n\n    if (currConstraint.type !== \"compatible-with\") {\n      throw Error(\"Unknown constraint type: \" + currConstraint.type);\n    }\n\n    // If you're not asking for a pre-release (and you are not in pre-releases-OK\n    // mode), you'll only get it if it was a top level explicit mention (eg, in\n    // the release).\n    if (!/-/.test(currConstraint.version) &&\n        /-/.test(candidateUV.version) && !resolveContext.useRCsOK) {\n      if (currConstraint.version === candidateUV.version)\n        return true;\n      if (!_.has(resolveContext.topLevelPrereleases, self.name) ||\n          !_.has(resolveContext.topLevelPrereleases[self.name],\n                 candidateUV.version)) {\n        return false;\n      }\n    }\n\n    // If the candidate version is less than the version named in the constraint,\n    // we are not satisfied.\n    if (PackageVersion.lessThan(candidateUV.version, currConstraint.version))\n      return false;\n\n    var myECV = resolver.getEarliestCompatibleVersion(\n      self.name, currConstraint.version);\n    // If the constraint is \"@1.2.3\" and 1.2.3 doesn't exist, then nothing can\n    // match. This is because we don't know the ECV (compatibility class) of\n    // 1.2.3!\n    if (!myECV)\n      return false;\n\n    // To be compatible, the two versions must have the same\n    // earliestCompatibleVersion. If the earliestCompatibleVersions haven't been\n    // overridden from their default, this means that the two versions have the\n    // same major version number.\n    return myECV === candidateUV.earliestCompatibleVersion;\n  });\n\n};\n\n// An object that records the general context of a resolve call. It can be\n// different for different resolve calls on the same Resolver, but is the same\n// for every ResolverState in a given call.\nvar ResolveContext = function () {\n  var self = this;\n  // unitName -> version string -> true\n  self.topLevelPrereleases = {};\n  self.useRCsOK = false;\n};\n","////////////////////////////////////////////////////////////////////////////////\n// ConstraintsList\n////////////////////////////////////////////////////////////////////////////////\n// A persistent data-structure that keeps references to Constraint objects\n// arranged by the \"name\" field of Constraint and exactness of the constraint.\n//\n// Internal structure has two maps, 'exact' and 'inexact'; they each map\n// unit name -> mori.set(Constraint).  (This relies on the fact that Constraints\n// are interned, so that mori.set can use reference identity.)\n//\n// We separate the constraints by exactness so that the iteration functions\n// (forPackage and each) can easily provide exact constraints before inexact\n// constraints, because exact constraints generally help the consumer pare down\n// their possibilities faster.\n// XXX This is just a theory, and it's not clear that we have benchmarks that\n//     prove it.\nConstraintSolver.ConstraintsList = function (prev) {\n  var self = this;\n\n  if (prev) {\n    self.exact = prev.exact;\n    self.inexact = prev.inexact;\n    self.minimalVersion = prev.minimalVersion;\n  } else {\n    self.exact = mori.hash_map();\n    self.inexact = mori.hash_map();\n    self.minimalVersion = mori.hash_map();\n  }\n};\n\nConstraintSolver.ConstraintsList.prototype.contains = function (c) {\n  var self = this;\n  var map = c.type === 'exactly' ? self.exact : self.inexact;\n  return !!mori.get_in(map, [c.name, c]);\n};\n\nConstraintSolver.ConstraintsList.prototype.getMinimalVersion = function (name) {\n  var self = this;\n  return mori.get(self.minimalVersion, name);\n};\n\n// returns a new version containing passed constraint\nConstraintSolver.ConstraintsList.prototype.push = function (c) {\n  var self = this;\n\n  if (self.contains(c)) {\n    return self;\n  }\n\n  var newList = new ConstraintSolver.ConstraintsList(self);\n  var mapField = c.type === 'exactly' ? 'exact' : 'inexact';\n  // Get the current constraints on this package of the exactness, or an empty\n  // set.\n  var currentConstraints = mori.get(newList[mapField], c.name, mori.set());\n  // Add this one.\n  newList[mapField] = mori.assoc(newList[mapField],\n                                 c.name,\n                                 mori.conj(currentConstraints, c));\n\n  // Maintain the \"minimal version\" that can satisfy these constraints.\n  // Note that this is one of the only pieces of the constraint solver that\n  // actually does logic on constraints (and thus relies on the restricted set\n  // of constraints that we support).\n  if (c.type !== 'any-reasonable') {\n    var minimal = mori.get(newList.minimalVersion, c.name);\n    if (!minimal || PackageVersion.lessThan(c.version, minimal)) {\n      newList.minimalVersion = mori.assoc(\n        newList.minimalVersion, c.name, c.version);\n    }\n  }\n  return newList;\n};\n\nConstraintSolver.ConstraintsList.prototype.forPackage = function (name, iter) {\n  var self = this;\n  var exact = mori.get(self.exact, name);\n  var inexact = mori.get(self.inexact, name);\n\n  var breaked = false;\n  var niter = function (constraint) {\n    if (iter(constraint) === BREAK) {\n      breaked = true;\n      return true;\n    }\n  };\n\n  exact && mori.some(niter, exact);\n  if (breaked)\n    return;\n  inexact && mori.some(niter, inexact);\n};\n\n// doesn't break on the false return value\nConstraintSolver.ConstraintsList.prototype.each = function (iter) {\n  var self = this;\n  _.each([self.exact, self.inexact], function (map) {\n    mori.each(map, function (nameAndConstraints) {\n      mori.each(mori.last(nameAndConstraints), iter);\n    });\n  });\n};\n\n// Checks if the passed unit version satisfies all of the constraints.\nConstraintSolver.ConstraintsList.prototype.isSatisfied = function (\n    uv, resolver, resolveContext) {\n  var self = this;\n\n  var satisfied = true;\n\n  self.forPackage(uv.name, function (c) {\n    if (! c.isSatisfied(uv, resolver, resolveContext)) {\n      satisfied = false;\n      return BREAK;\n    }\n  });\n\n  return satisfied;\n};\n\nConstraintSolver.ConstraintsList.prototype.toString = function (options) {\n  var self = this;\n  options = options || {};\n\n  var strs = [];\n\n  self.each(function (c) {\n    strs.push(c.toString({removeUnibuild: options.removeUnibuild}));\n  });\n\n  strs.sort();\n\n  return \"<constraints list: \" + strs.join(\", \") + \">\";\n};\n","var util = Npm.require('util');\n\nResolverState = function (resolver, resolveContext) {\n  var self = this;\n  self._resolver = resolver;\n  self._resolveContext = resolveContext;\n  // The versions we've already chosen.\n  // unitName -> UnitVersion\n  self.choices = mori.hash_map();\n  // Units we need, but haven't chosen yet.\n  // unitName -> sorted vector of (UnitVersions)\n  self._dependencies = mori.hash_map();\n  // Constraints that apply.\n  self.constraints = new ConstraintSolver.ConstraintsList;\n  // How we've decided things about units.\n  // unitName -> set(list (reversed) of UVs that led us here).\n  self._unitPathways = mori.hash_map();\n  // If we've already hit a contradiction.\n  self.error = null;\n};\n\n_.extend(ResolverState.prototype, {\n  addConstraint: function (constraint, pathway) {\n    var self = this;\n    if (self.error)\n      return self;\n\n    // Add the constraint.\n    var newConstraints = self.constraints.push(constraint);\n    // If we already had the constraint, we're done.\n    if (self.constraints === newConstraints)\n      return self;\n\n    self = self._clone();\n    self.constraints = newConstraints;\n    self._addPathway(constraint.name, pathway);\n\n    var chosen = mori.get(self.choices, constraint.name);\n    if (chosen &&\n        !constraint.isSatisfied(chosen, self._resolver, self._resolveContext)) {\n      // This constraint conflicts with a choice we've already made!\n      self.error = util.format(\n        \"conflict: constraint %s is not satisfied by %s.\\n\" +\n        \"Constraints on %s come from:\\n%s\",\n        constraint.toString({removeUnibuild: true}),\n        chosen.version,\n        removeUnibuild(constraint.name),\n        self._shownPathwaysForConstraintsIndented(constraint.name));\n      return self;\n    }\n\n    var alternatives = mori.get(self._dependencies, constraint.name);\n    if (alternatives) {\n      // Note: filter preserves order, which is important.\n      var newAlternatives = filter(alternatives, function (unitVersion) {\n        return constraint.isSatisfied(\n          unitVersion, self._resolver, self._resolveContext);\n      });\n      if (mori.is_empty(newAlternatives)) {\n        self.error = util.format(\n          \"conflict: constraints on %s cannot all be satisfied.\\n\" +\n            \"Constraints come from:\\n%s\",\n          removeUnibuild(constraint.name),\n          self._shownPathwaysForConstraintsIndented(constraint.name));\n      } else if (mori.count(newAlternatives) === 1) {\n        // There's only one choice, so we can immediately choose it.\n        self = self.addChoice(mori.first(newAlternatives), pathway);\n      } else if (mori.count(newAlternatives) !== mori.count(alternatives)) {\n        self._dependencies = mori.assoc(\n          self._dependencies, constraint.name, newAlternatives);\n      }\n    }\n    return self;\n  },\n  addDependency: function (unitName, pathway) {\n    var self = this;\n\n    if (self.error || mori.has_key(self.choices, unitName)\n        || mori.has_key(self._dependencies, unitName)) {\n      return self;\n    }\n\n    self = self._clone();\n\n    if (!_.has(self._resolver.unitsVersions, unitName)) {\n      self.error = \"unknown package: \" + removeUnibuild(unitName);\n      return self;\n    }\n\n    // Note: relying on sortedness of unitsVersions so that alternatives is\n    // sorted too (the estimation function uses this).\n    var alternatives = filter(self._resolver.unitsVersions[unitName], function (uv) {\n      return self.isSatisfied(uv);\n      // XXX hang on to list of violated constraints and use it in error\n      // message\n    });\n\n    if (mori.is_empty(alternatives)) {\n      self.error = util.format(\n        \"conflict: constraints on %s cannot be satisfied.\\n\" +\n          \"Constraints come from:\\n%s\",\n        removeUnibuild(unitName),\n        self._shownPathwaysForConstraintsIndented(unitName));\n      return self;\n    } else if (mori.count(alternatives) === 1) {\n      // There's only one choice, so we can immediately choose it.\n      self = self.addChoice(mori.first(alternatives), pathway);\n    } else {\n      self._dependencies = mori.assoc(\n        self._dependencies, unitName, alternatives);\n      self._addPathway(unitName, pathway);\n    }\n\n    return self;\n  },\n  addChoice: function (uv, pathway) {\n    var self = this;\n\n    if (self.error)\n      return self;\n    if (mori.has_key(self.choices, uv.name))\n      throw Error(\"Already chose \" + uv.name);\n\n    self = self._clone();\n\n    // Does adding this choice break some constraints we already have?\n    if (!self.isSatisfied(uv)) {\n      // This shouldn't happen: all calls to addChoice should occur based on\n      // choosing it from a list of satisfied alternatives.\n      throw new Error(\"try to choose an unsatisfied version?\");\n    }\n\n    // Great, move it from dependencies to choices.\n    self.choices = mori.assoc(self.choices, uv.name, uv);\n    self._dependencies = mori.dissoc(self._dependencies, uv.name);\n    self._addPathway(uv.name, pathway);\n\n    // Since we're committing to this version, we're committing to all it\n    // implies.\n    var pathwayIncludingUv = mori.cons(uv, pathway);\n    uv.constraints.each(function (constraint) {\n      self = self.addConstraint(constraint, pathwayIncludingUv);\n    });\n    _.each(uv.dependencies, function (unitName) {\n      self = self.addDependency(unitName, pathwayIncludingUv);\n    });\n\n    return self;\n  },\n  // this mutates self, so only call on a newly _clone'd and not yet returned\n  // object.\n  _addPathway: function (unitName, pathway) {\n    var self = this;\n    self._unitPathways = mori.assoc(\n      self._unitPathways, unitName,\n      mori.conj(mori.get(self._unitPathways, unitName, mori.set()),\n                pathway));\n  },\n  success: function () {\n    var self = this;\n    return !self.error && mori.is_empty(self._dependencies);\n  },\n  eachDependency: function (iter) {\n    var self = this;\n    mori.some(function (nameAndAlternatives) {\n      return BREAK == iter(mori.first(nameAndAlternatives),\n                           mori.last(nameAndAlternatives));\n    }, self._dependencies);\n  },\n  isSatisfied: function (uv) {\n    var self = this;\n    return self.constraints.isSatisfied(uv, self._resolver, self._resolveContext);\n  },\n  somePathwayForUnitName: function (unitName) {\n    var self = this;\n    var pathways = mori.get(self._unitPathways, unitName);\n    if (!pathways)\n      return mori.list();\n    return mori.first(pathways);\n  },\n  _clone: function () {\n    var self = this;\n    var clone = new ResolverState(self._resolver, self._resolveContext);\n    _.each(['choices', '_dependencies', 'constraints', 'error', '_unitPathways'], function (field) {\n      clone[field] = self[field];\n    });\n    return clone;\n  },\n  _shownPathwaysForConstraints: function (unitName) {\n    var self = this;\n    var pathways = mori.into_array(mori.map(function (pathway) {\n      return showPathway(pathway, unitName);\n    }, mori.get(self._unitPathways, unitName)));\n    pathways.sort();\n    pathways = _.uniq(pathways, true);\n    return pathways;\n  },\n  _shownPathwaysForConstraintsIndented: function (unitName) {\n    var self = this;\n    return _.map(self._shownPathwaysForConstraints(unitName), function (pathway) {\n      return \"  \" + (pathway ? pathway : \"<top level>\");\n    }).join(\"\\n\");\n  }\n});\n\n// Helper for filtering a vector in mori. mori.filter returns a lazy sequence,\n// which is cool, but we actually do want to coerce to a vector since we (eg the\n// estimation function) runs mori.last on it a bunch and we'd like to only\n// do the O(n) work once.\nvar filter = function (v, pred) {\n  return mori.into(mori.vector(), mori.filter(pred, v));\n};\n\n// Users are mostly confused by seeing \"package#web.browser\" instead of just\n// \"package\". Remove it for error messages.\nremoveUnibuild = function (unitName) {\n  // For debugging constraint solver issues.\n  if (process.env.METEOR_SHOW_UNIBUILDS)\n    return unitName;\n  return unitName.split('#')[0];\n};\n\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\n// XXX how many copies of this do we have in Meteor?\nvar startsWith = function(str, starts) {\n  return str.length >= starts.length &&\n    str.substring(0, starts.length) === starts;\n};\n\nvar showPathway = function (pathway, dropIfFinal) {\n  var pathUnits = mori.into_array(mori.map(function (uv) {\n    return uv.toString({removeUnibuild: true});\n  }, mori.reverse(pathway)));\n\n  var dropPrefix = removeUnibuild(dropIfFinal) + '@';\n  while (pathUnits.length && startsWith(_.last(pathUnits), dropPrefix)) {\n    pathUnits.pop();\n  }\n\n  // This is a bit of a hack: we're using _.uniq in \"it's sorted\" mode, whose\n  // implementation is \"drop adjacent duplicates\". This is what we want (we're\n  // trying to avoid seeing \"foo -> foo\" which represents \"foo#os ->\n  // foo#web.browser\") even though it's not actually sorted.\n  pathUnits = _.uniq(pathUnits, true);\n  return pathUnits.join(' -> ');\n};\n","PriorityQueue = function () {\n  var self = this;\n  var compareArrays = function (a, b) {\n    for (var i = 0; i < a.length; i++)\n      if (a[i] !== b[i])\n        if (a[i] instanceof Array)\n          return compareArrays(a[i], b[i]);\n        else\n          return a[i] - b[i];\n\n    return 0;\n  };\n  // id -> cost\n  self._heap = new MinHeap(function (a, b) {\n    return compareArrays(a, b);\n  });\n\n  // id -> reference to item\n  self._items = {};\n};\n\n_.extend(PriorityQueue.prototype, {\n  push: function (item, cost) {\n    var self = this;\n    var id = Random.id();\n    self._heap.set(id, cost);\n    self._items[id] = item;\n  },\n  top: function () {\n    var self = this;\n\n    if (self.empty())\n      throw new Error(\"The queue is empty\");\n\n    var id = self._heap.minElementId();\n    return self._items[id];\n  },\n  pop: function () {\n    var self = this;\n\n    if (self.empty())\n      throw new Error(\"The queue is empty\");\n\n    var id = self._heap.minElementId();\n    var item = self._items[id];\n\n    delete self._items[id];\n    self._heap.remove(id);\n\n    return item;\n  },\n  empty: function () {\n    var self = this;\n    return self._heap.empty();\n  },\n  size: function () {\n    var self = this;\n    return self._heap.size();\n  }\n});\n\n\n"]}
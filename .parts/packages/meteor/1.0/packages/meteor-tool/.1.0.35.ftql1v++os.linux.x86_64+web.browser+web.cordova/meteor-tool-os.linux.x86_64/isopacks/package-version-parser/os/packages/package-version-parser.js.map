{"version":3,"file":"/packages/package-version-parser.js","sources":["package-version-parser/package-version-parser.js"],"names":[],"mappings":";;;;;;;;AAAA,wE;AACA,uE;AACA,yE;AACA,mE;AACA,4C;;AAEA,O;AACA,a;AACA,e;AACA,Q;AACA,2B;AACA,C;;AAEA,iE;AACA,4C;;AAEA,4D;AACA,E;AACA,+C;AACA,wB;AACA,uC;AACA,E;AACA,yE;AACA,c;AACA,kD;AACA,yD;AACA,yC;AACA,2C;AACA,kB;AACA,uD;AACA,sD;AACA,4B;AACA,gE;AACA,gC;AACA,uC;AACA,8B;AACA,iC;AACA,8B;AACA,mE;AACA,0C;AACA,oC;AACA,8B;AACA,uE;AACA,0C;AACA,K;AACA,G;AACA,U;AACA,kC;AACA,0C;AACA,sB;AACA,kC;AACA,I;AACA,E;;AAEA,sE;AACA,8D;AACA,mD;AACA,wD;AACA,E;AACA,8E;AACA,e;AACA,yE;AACA,qE;AACA,wE;AACA,gD;AACA,6E;AACA,6E;AACA,6C;AACA,E;AACA,sE;AACA,6D;AACA,kE;AACA,mB;AACA,gD;AACA,iD;AACA,uC;;AAEA,8B;AACA,mB;AACA,a;AACA,2B;AACA,6D;AACA,E;;AAEA,mE;AACA,mE;AACA,mD;AACA,4D;AACA,8B;AACA,a;;AAEA,4D;AACA,c;AACA,mC;AACA,qB;AACA,0C;AACA,qF;;AAEA,6C;AACA,kD;AACA,0B;AACA,kF;AACA,Y;AACA,wB;AACA,Q;;AAEA,yF;AACA,8D;AACA,mD;AACA,Y;AACA,oG;AACA,K;;AAEA,6C;AACA,iE;AACA,+C;AACA,kD;AACA,S;AACA,E;;AAEA,uF;AACA,iD;AACA,gD;AACA,E;;AAEA,iF;AACA,E;AACA,8C;AACA,0C;AACA,wD;AACA,qC;AACA,e;AACA,gE;AACA,+B;AACA,C;;AAEA,8E;AACA,iB;AACA,gD;AACA,iD;AACA,iD;;AAEA,gF;AACA,0E;AACA,qC;AACA,gD;AACA,gE;AACA,G;;AAEA,6E;AACA,wB;AACA,iD;AACA,E;;AAEA,mD;AACA,6E;AACA,wE;AACA,oC;AACA,6B;AACA,4E;AACA,mB;AACA,+B;AACA,4B;AACA,0E;AACA,0E;AACA,2E;AACA,yE;AACA,4B;AACA,E;AACA,W;AACA,qE;AACA,+D;AACA,0B;AACA,8D;;AAEA,uB;AACA,uB;AACA,G;;AAEA,wC;AACA,iC;AACA,4C;AACA,U;AACA,yC;AACA,G;;AAEA,sD;AACA,0C;;AAEA,+B;AACA,oD;AACA,G;;AAEA,sC;;AAEA,qB;AACA,E;;;AAGA,+E;AACA,E;AACA,oE;AACA,+E;AACA,8B;AACA,2D;;AAEA,sE;AACA,uD;;AAEA,qC;AACA,8E;AACA,4E;AACA,8D;AACA,8C;AACA,8B;AACA,kE;AACA,kC;AACA,I;;AAEA,iD;AACA,wB;AACA,4B;AACA,gE;AACA,gC;AACA,G;;AAEA,wB;AACA,wD;AACA,G;;AAEA,sB;AACA,E;;;AAGA,2D;AACA,2C;AACA,6D;AACA,0B;;AAEA,6C;;AAEA,yB;AACA,kC;;AAEA,4B;AACA,sC;AACA,iC;AACA,G;;AAEA,yB;AACA,mC;AACA,8B;AACA,oE;AACA,mC;AACA,K;AACA,wC;AACA,U;AACA,iC;AACA,G;;AAEA,gD;AACA,4B;AACA,iD;AACA,8E;AACA,wB;AACA,G;;AAEA,oB;AACA,c;AACA,I;;AAEA,yE;AACA,8C;;AAEA,wE;AACA,oD;AACA,uB;AACA,4B;AACA,oD;AACA,sB;AACA,G;;AAEA,uC;AACA,2D;AACA,8B;AACA,qD;AACA,gC;AACA,sD;AACA,K;;AAEA,oB;AACA,E;;AAEA,0D;AACA,0B;;AAEA,mD;AACA,gB;AACA,2C;AACA,8B;AACA,wE;AACA,iF;AACA,0E;AACA,gF;AACA,K;AACA,4B;AACA,8E;AACA,kE;AACA,G;AACA,mC;AACA,oF;AACA,G;AACA,+B;AACA,uE;AACA,G;AACA,E;;AAEA,kD;AACA,6B;AACA,8B;AACA,U;AACA,E;;AAEA,yD;AACA,yE;AACA,E;;;AAGA,mE;AACA,4B;AACA,E;AACA,wE;AACA,6C;AACA,8D;AACA,qC;AACA,uE;AACA,mE;AACA,4E;AACA,uB;AACA,sC;AACA,sC;AACA,E;;AAEA,4C;AACA,6C;AACA,4C;AACA,E","sourcesContent":["// This file is in tools/package-version-parser.js and is symlinked into\n// packages/package-version-parser/package-version-parser.js. It's part\n// of both the tool and the package!  We don't use uniload for it because\n// it needs to be used as part of initializing the uniload catalog.\nvar inTool = typeof Package === 'undefined';\n\nvar PV;\nif (inTool) {\n  PV = exports;\n} else {\n  PackageVersion = PV = {};\n}\n\nvar semver = inTool ? require ('semver') : Npm.require('semver');\nvar __ = inTool ? require('underscore') : _;\n\n// Takes in a meteor version, for example 1.2.3-rc5_1+12345.\n//\n// Returns an object composed of the following:\n//   semver: (ex: 1.2.3)\n//   wrapNum: 0 or a valid wrap number.\n//\n// Throws if the wrapNumber is invalid, or if the version cannot be split\n// reasonably.\nvar extractSemverPart = function (versionString) {\n  if (!versionString) return { semver: \"\", wrapNum: -1 };\n  var noBuild = versionString.split('+');\n  var splitVersion = noBuild[0].split('_');\n  var wrapNum = 0;\n  // If we find two +s, or two _, that's super invalid.\n  if (noBuild.length > 2 || splitVersion.length > 2) {\n    throwVersionParserError(\n      \"Version string must look like semver (eg '1.2.3'), not '\"\n        + versionString + \"'.\");\n  } else if (splitVersion.length > 1) {\n    wrapNum = splitVersion[1];\n    if (!/^\\d+$/.test(wrapNum)) {\n      throwVersionParserError(\n        \"The wrap number (after _) must contain only digits, so \" +\n          versionString + \" is invalid.\");\n    } else if (wrapNum[0] === \"0\") {\n      throwVersionParserError(\n        \"The wrap number (after _) must not have a leading zero, so \" +\n          versionString + \" is invalid.\");\n    }\n  }\n  return {\n    semver: (noBuild.length > 1) ?\n      splitVersion[0] + \"+\" + noBuild[1] :\n      splitVersion[0],\n    wrapNum: parseInt(wrapNum, 10)\n  };\n};\n\n// Converts a meteor version into a large floating point number, which\n// is (more or less [*]) unique to that version. Satisfies the\n// following guarantee: If PV.lessThan(v1, v2) then\n// PV.versionMagnitude(v1) < PV.versionMagnitude(v2) [*]\n//\n// [* XXX!] We don't quite satisfy the uniqueness and comparison properties in\n// these cases:\n// 1. If any of the version parts are greater than 100 (pretty unlikely?)\n// 2. If we're dealing with a prerelease version, we only look at the\n//    first two characters of each prerelease part. So, \"1.0.0-beta\" and\n//    \"1.0.0-bear\" will have the same magnitude.\n// 3. If we're dealing with a prerelease version with more than two parts, eg\n//    \"1.0.0-rc.0.1\". In this comparison may fail since we'd get to the limit\n//    of JavaScript floating point precision.\n//\n// If we wanted to fix this, we'd make this function return a BigFloat\n// instead of a vanilla JavaScript number. That will make the\n// constraint solver slower (by how much?), and would require some\n// careful thought.\nPV.versionMagnitude = function (versionString) {\n  var version = extractSemverPart(versionString);\n  var v = semver.parse(version.semver);\n\n  return v.major * 100 * 100 +\n    v.minor * 100 +\n    v.patch +\n    version.wrapNum / 100 +\n    prereleaseIdentifierToFraction(v.prerelease) / 100 / 100;\n};\n\n// Accepts an array, eg [\"rc\", 2, 3]. Returns a number in the range\n// (-1, 0].  An empty array returns 0. A non-empty string returns a\n// number that is \"as large\" as the its precedence.\nvar prereleaseIdentifierToFraction = function (prerelease) {\n  if (prerelease.length === 0)\n    return 0;\n\n  return _.reduce(prerelease, function (memo, part, index) {\n    var digit;\n    if (typeof part === 'number') {\n      digit = part+1;\n    } else if (typeof part === 'string') {\n      var VALID_CHARACTERS = \"-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n      var validCharToNumber = function (ch) {\n        var result = VALID_CHARACTERS.indexOf(ch);\n        if (result === -1)\n          throw new Error(\"Unexpected character in prerelease identifier: \" + ch);\n        else\n          return result;\n      };\n\n      digit = 101 + // Numeric parts always have lower precedence than non-numeric parts.\n        validCharToNumber(part[0]) * VALID_CHARACTERS.length +\n        (part[1] ? validCharToNumber(part[1]) : 0);\n    } else {\n      throw new Error(\"Unexpected prerelease identifier part: \" + part + \" of type \" + typeof part);\n    }\n\n    // 3000 > 101 + VALID_CHARACTERS.length *\n    // VALID_CHARACTERS.length. And there's a test to verify this\n    // (\"test the edges of `versionMagnitude`\")\n    return memo + digit / Math.pow(3000, index+1);\n  }, -1);\n};\n\n// Takes in two meteor versions. Returns true if the first one is less than the second.\nPV.lessThan = function (versionOne, versionTwo) {\n  return PV.compare(versionOne, versionTwo) < 0;\n};\n\n// Given a string version, computes its default ECV (not counting any overrides).\n//\n// versionString: valid meteor version string.\nPV.defaultECV = function (versionString) {\n  var version = extractSemverPart(versionString).semver;\n  var parsed = semver.parse(version);\n  if (! parsed)\n     throwVersionParserError(\"not a valid version: \" + version);\n  return parsed.major + \".0.0\";\n}\n\n// Takes in two meteor versions. Returns 0 if equal, 1 if v1 is greater, -1 if\n// v2 is greater.\nPV.compare = function (versionOne, versionTwo) {\n  var meteorVOne = extractSemverPart(versionOne);\n  var meteorVTwo = extractSemverPart(versionTwo);\n\n  // Wrap numbers only matter if the semver is equal, so if they don't even have\n  // wrap numbers, or if their semver is not equal, then we should let the\n  // semver library resolve this one.\n  if (meteorVOne.semver !== meteorVTwo.semver) {\n    return semver.compare(meteorVOne.semver, meteorVTwo.semver);\n  }\n\n  // If their semver components are equal, then the one with the smaller wrap\n  // numbers is smaller.\n  return meteorVOne.wrapNum - meteorVTwo.wrapNum;\n};\n\n// Conceptually we have three types of constraints:\n// 1. \"compatible-with\" - A@x.y.z - constraints package A to version x.y.z or\n//    higher, as long as the version is backwards compatible with x.y.z.\n//    \"pick A compatible with x.y.z\"\n//    It is the default type.\n// 2. \"exactly\" - A@=x.y.z - constraints package A only to version x.y.z and\n//    nothing else.\n//    \"pick A exactly at x.y.z\"\n// 3. \"any-reasonable\" - \"A\"\n//    Basically, this means any version of A ... other than ones that have\n//    dashes in the version (ie, are prerelease) ... unless the prerelease\n//    version has been explicitly selected (which at this stage in the game\n//    means they are mentioned in a top-level constraint in the top-level\n//    call to the resolver).\n//\n// Options:\n//    removeBuildIDs:  Remove the build ID at the end of the version.\nPV.parseVersionConstraint = function (versionString, options) {\n  options = options || {};\n  var versionDesc = { version: null, type: \"any-reasonable\" };\n\n  if (!versionString) {\n    return versionDesc;\n  }\n\n  if (versionString.charAt(0) === '=') {\n    versionDesc.type = \"exactly\";\n    versionString = versionString.substr(1);\n  } else {\n    versionDesc.type = \"compatible-with\";\n  }\n\n  // This will throw if the version string is invalid.\n  PV.getValidServerVersion(versionString);\n\n  if (options.removeBuildIDs) {\n    versionString = PV.removeBuildID(versionString);\n  }\n\n  versionDesc.version = versionString;\n\n  return versionDesc;\n};\n\n\n// Check to see if the versionString that we pass in is a valid meteor version.\n//\n// Returns a valid meteor version string that can be included in the\n// server. That means that it has everything EXCEPT the build id. Throws if the\n// entered string was invalid.\nPV.getValidServerVersion = function (meteorVersionString) {\n\n  // Strip out the wrapper num, if present and check that it is valid.\n  var version = extractSemverPart(meteorVersionString);\n\n  var versionString = version.semver;\n  // NPM's semver spec supports things like 'v1.0.0' and considers them valid,\n  // but we don't. Everything before the + or - should be of the x.x.x form.\n  var mainVersion = versionString.split('+')[0].split('-')[0];\n  if (! /^\\d+\\.\\d+\\.\\d+$/.test(mainVersion)) {\n      throwVersionParserError(\n        \"Version string must look like semver (eg '1.2.3'), not '\"\n          + versionString + \"'.\");\n  };\n\n  var cleanVersion = semver.valid(versionString);\n  if (! cleanVersion ) {\n    throwVersionParserError(\n      \"Version string must look like semver (eg '1.2.3'), not '\"\n        + versionString + \"'.\");\n  }\n\n  if (version.wrapNum) {\n    cleanVersion = cleanVersion + \"_\" + version.wrapNum;\n  }\n\n  return cleanVersion;\n};\n\n\nPV.parseConstraint = function (constraintString, options) {\n  if (typeof constraintString !== \"string\")\n    throw new TypeError(\"constraintString must be a string\");\n  options = options || {};\n\n  var splitted = constraintString.split('@');\n\n  var name = splitted[0];\n  var versionString = splitted[1];\n\n  if (splitted.length > 2) {\n    // throw error complaining about @\n    PV.validatePackageName('a@');\n  }\n\n  if (options.archesOK) {\n    var newNames = name.split('#');\n    if (newNames.length > 2) {\n      // It is invalid and should register as such. This will throw.\n      PV.validatePackageName(name);\n    }\n    PV.validatePackageName(newNames[0]);\n  } else {\n    PV.validatePackageName(name);\n  }\n\n  if (splitted.length === 2 && !versionString) {\n    throwVersionParserError(\n      \"Version constraint for package '\" + name +\n        \"' cannot be empty; leave off the @ if you don't want to constrain \" +\n        \"the version.\");\n  }\n\n  var constraint = {\n    name: name\n  };\n\n  // Before we parse through versionString, we save it for future output.\n  constraint.constraintString = versionString;\n\n  // If we did not specify a version string, then our only constraint is\n  // any-reasonable, so we are going to return that.\n  if (!versionString) {\n    constraint.constraints =\n      [ { version: null, type: \"any-reasonable\" } ];\n    return constraint;\n  }\n\n  // Let's parse out the versionString.\n  var versionConstraints = versionString.split(/ *\\|\\| */);\n  constraint.constraints = [];\n  __.each(versionConstraints, function (versionCon) {\n    constraint.constraints.push(\n      PV.parseVersionConstraint(versionCon, options));\n  });\n\n  return constraint;\n};\n\nPV.validatePackageName = function (packageName, options) {\n  options = options || {};\n\n  var badChar = packageName.match(/[^a-z0-9:.\\-]/);\n  if (badChar) {\n    if (options.detailedColonExplanation) {\n      throwVersionParserError(\n        \"Bad character in package name: \" + JSON.stringify(badChar[0]) +\n          \".\\n\\nPackage names can only contain lowercase ASCII alphanumerics, \" +\n          \"dash, or dot.\\nIf you plan to publish a package, it must be \" +\n          \"prefixed with your\\nMeteor Developer Account username and a colon.\");\n    }\n    throwVersionParserError(\n      \"Package names can only contain lowercase ASCII alphanumerics, dash, \" +\n        \"dot, or colon, not \" + JSON.stringify(badChar[0]) + \".\");\n  }\n  if (!/[a-z]/.test(packageName)) {\n    throwVersionParserError(\"Package names must contain a lowercase ASCII letter.\");\n  }\n  if (packageName[0] === '.') {\n    throwVersionParserError(\"Package names may not begin with a dot.\");\n  }\n};\n\nvar throwVersionParserError = function (message) {\n  var e = new Error(message);\n  e.versionParserError = true;\n  throw e;\n};\n\nPV.constraintToFullString = function (parsedConstraint) {\n  return parsedConstraint.name + \"@\" + parsedConstraint.constraintString;\n};\n\n\n// Return true if the version constraint was invalid prior to 0.9.3\n// (adding _ and || support)\n//\n// NOTE: this is not used on the client yet. This package is used by the\n// package server to determine what is valid.\nPV.invalidFirstFormatConstraint = function (validConstraint) {\n  if (!validConstraint) return false;\n  // We can check this easily right now, because we introduced some new\n  // characters. Anything with those characters is invalid prior to\n  // 0.9.3. XXX: If we ever have to go through these, we should write a more\n  // complicated regex.\n  return (/_/.test(validConstraint) ||\n          /\\|/.test(validConstraint));\n};\n\n// Remove a suffix like \"+local\" if present.\nPV.removeBuildID = function (versionString) {\n  return versionString.replace(/\\+.*$/, '');\n};\n"]}
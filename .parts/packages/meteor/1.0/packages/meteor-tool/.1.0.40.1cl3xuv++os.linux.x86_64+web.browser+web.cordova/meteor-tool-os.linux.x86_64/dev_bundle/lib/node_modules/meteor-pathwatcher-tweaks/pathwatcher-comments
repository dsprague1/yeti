Re the "keeping open Node" issue --- might something like this (a combination of
your two patches) be the best of both worlds? Like your first patch it does real
refcounting, but like your second patch it is just using uv_ref/uv_unref, not
the more heavy-handed creation and deletion of the whole uv_async_init thing.

(I suspect a possible problem with your first patch is that maaaaaaybe even
after you've called inotify_rm_watch or closed the kevent fd, already queued
events for that watch can still be returned through the inotify/queue?  Leading
to call to PostEventAndWait with a closed uv_async_t?  Maybe not though.)

diff --git a/src/common.cc b/src/common.cc
index 883e360..32e5ae5 100644
--- a/src/common.cc
+++ b/src/common.cc
@@ -1,6 +1,7 @@
 #include "common.h"
 
 static uv_async_t g_async;
+static int g_watch_count;
 static uv_sem_t g_semaphore;
 static uv_thread_t g_thread;
 
@@ -66,6 +67,7 @@ static void MakeCallbackInMainThread(uv_async_t* handle, int status) {
 void CommonInit() {
   uv_sem_init(&g_semaphore, 0);
   uv_async_init(uv_default_loop(), &g_async, MakeCallbackInMainThread);
+  g_watch_count = 0;
   // As long as any uv_ref'd uv_async_t handle remains active, the node
   // process will never exit, so we must call uv_unref here (#47).
   uv_unref(reinterpret_cast<uv_handle_t*>(&g_async));
@@ -115,6 +117,10 @@ NAN_METHOD(Watch) {
   if (!PlatformIsHandleValid(handle))
     return NanThrowTypeError("Unable to watch path");
 
+  if (g_watch_count++ == 0) {
+    uv_ref(reinterpret_cast<uv_handle_t*>(&g_async));
+  }
+
   NanReturnValue(WatcherHandleToV8Value(handle));
 }
 
@@ -125,5 +131,10 @@ NAN_METHOD(Unwatch) {
     return NanThrowTypeError("Handle type required");
 
   PlatformUnwatch(V8ValueToWatcherHandle(args[0]));
+
+  if (--g_watch_count == 0) {
+    uv_unref(reinterpret_cast<uv_handle_t*>(&g_async));
+  }
+
   NanReturnUndefined();
 }




Still confused about the vim issue.

Make sure second resolution worked out.

Can we avoid requiring pathwatcher until we actually call pathwatcher.watch?

constructL
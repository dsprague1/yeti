{"version":3,"sources":["constraint-solver/datatypes.js","constraint-solver/catalog-cache.js","constraint-solver/catalog-loader.js","constraint-solver/constraint-solver-input.js","constraint-solver/constraint-solver.js","constraint-solver/resolver.js","constraint-solver/constraints-list.js","constraint-solver/resolver-state.js","constraint-solver/priority-queue.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,sB;;AAEA,wB;AACA,0B;;AAEA,4B;;AAEA,yC;AACA,oD;AACA,yB;AACA,yB;;AAEA,yB;AACA,yB;AACA,E;;AAEA,+D;AACA,8D;AACA,mD;AACA,uD;AACA,2C;AACA,E;;AAEA,kD;AACA,6B;AACA,mD;AACA,wD;AACA,U;AACA,2D;AACA,G;AACA,E;;AAEA,qB;;AAEA,mE;AACA,4B;;AAEA,qD;AACA,sE;AACA,8C;AACA,8D;AACA,G;AACA,c;AACA,yB;AACA,G;;AAEA,uC;AACA,sB;;AAEA,c;AACA,uB;AACA,yB;AACA,K;AACA,G;AACA,E;;AAEA,6D;AACA,6D;AACA,gD;AACA,wC;AACA,oB;AACA,oB;AACA,G;AACA,a;AACA,E;;AAEA,2C;AACA,qB;;AAEA,8B;AACA,kB;AACA,uB;AACA,G;;AAEA,+C;;AAEA,uC;AACA,E;;;;;;;;;;;;;;;;;;;AC7EA,0B;;AAEA,yC;AACA,iC;AACA,E;;AAEA,4D;AACA,+B;AACA,uD;AACA,8E;AACA,0B;AACA,yE;AACA,mC;AACA,qD;AACA,sB;AACA,E;;AAEA,2E;AACA,4D;AACA,E;;AAEA,qE;AACA,mB;AACA,mB;AACA,qE;AACA,+B;;AAEA,wB;AACA,uC;AACA,wD;AACA,G;;AAEA,mC;AACA,2B;AACA,G;AACA,4B;;AAEA,yB;AACA,0C;AACA,6B;AACA,gC;AACA,mC;AACA,8D;AACA,oC;AACA,K;AACA,0B;AACA,K;AACA,E;;AAEA,qE;AACA,wD;AACA,iD;AACA,8D;AACA,wB;AACA,yC;AACA,2C;AACA,G;AACA,iC;AACA,E;;AAEA,iE;AACA,6B;AACA,mE;AACA,0C;AACA,wC;AACA,E;;AAEA,oD;AACA,kB;AACA,gB;AACA,4D;AACA,sD;AACA,qD;AACA,qD;AACA,4B;AACA,O;AACA,K;AACA,wB;AACA,E;;AAEA,+C;AACA,+B;;AAEA,oC;AACA,6C;AACA,+B;AACA,6C;AACA,4B;AACA,6B;AACA,uC;AACA,6C;AACA,U;AACA,K;AACA,e;AACA,E;;AAEA,yE;AACA,kE;AACA,wB;AACA,gE;AACA,kB;AACA,uC;AACA,yD;AACA,6C;AACA,e;AACA,Y;AACA,K;AACA,G;AACA,E;;AAEA,oE;AACA,uE;AACA,gD;AACA,uE;AACA,kB;AACA,mC;AACA,uD;AACA,e;AACA,Y;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACzHA,wB;AACA,0B;;AAEA,qE;AACA,6D;AACA,gD;AACA,E;AACA,sE;AACA,oE;AACA,oE;AACA,mE;AACA,kE;AACA,iE;AACA,8D;AACA,mE;AACA,iC;;AAEA,2D;AACA,kB;;AAEA,6B;AACA,qC;;AAEA,uC;AACA,E;;AAEA,8C;AACA,E;AACA,4C;AACA,6C;AACA,E;AACA,sD;AACA,sD;AACA,4D;;AAEA,0C;AACA,qD;AACA,0D;AACA,gD;AACA,yD;AACA,uB;AACA,O;;AAEA,8C;AACA,kE;AACA,wB;AACA,K;;AAEA,2E;AACA,+D;AACA,K;AACA,E;;AAEA,qE;AACA,uD;AACA,0E;AACA,0D;AACA,8C;AACA,oD;AACA,G;;AAEA,kD;AACA,E;;AAEA,iE;AACA,kB;AACA,gC;AACA,2D;AACA,sC;AACA,8B;AACA,sD;AACA,+C;AACA,sD;AACA,K;AACA,K;AACA,E;;AAEA,yE;AACA,yB;AACA,8E;AACA,kB;;AAEA,0E;AACA,uE;AACA,wE;AACA,iD;AACA,qB;AACA,gC;;AAEA,oC;AACA,iD;AACA,2C;AACA,8B;AACA,K;AACA,I;;AAEA,+B;;AAEA,4B;AACA,kC;AACA,kC;AACA,wE;AACA,kE;AACA,+C;AACA,0B;AACA,S;AACA,O;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC5GA,wB;AACA,0B;;AAEA,qE;AACA,oE;AACA,4D;AACA,wE;AACA,0B;;AAEA,mC;AACA,iC;AACA,uC;AACA,qE;AACA,2D;;AAEA,qC;AACA,mD;AACA,gC;AACA,oC;AACA,iE;AACA,0D;;AAEA,mC;AACA,E;;AAEA,+D;AACA,kB;;AAEA,6C;;AAEA,gD;AACA,mC;AACA,K;AACA,kD;AACA,2C;AACA,K;AACA,6D;AACA,mC;AACA,K;;AAEA,kE;AACA,iE;AACA,E;;AAEA,6C;AACA,kB;AACA,a;AACA,oC;AACA,uD;AACA,0B;AACA,O;AACA,gD;AACA,I;AACA,iE;AACA,wC;AACA,4B;AACA,+B;AACA,G;AACA,iD;AACA,6D;AACA,G;AACA,uC;AACA,iD;AACA,I;AACA,a;AACA,E;;AAEA,wC;AACA,c;AACA,2B;AACA,0B;AACA,yB;AACA,2C;AACA,+D;AACA,gE;AACA,qC;AACA,K;;AAEA,sB;AACA,qB;AACA,4C;AACA,sC;AACA,O;AACA,mD;AACA,K;AACA,2B;AACA,yD;AACA,4C;AACA,O;AACA,E;;AAEA,oE;AACA,kE;AACA,qE;AACA,kE;AACA,sE;AACA,qD;AACA,wC;AACA,uB;AACA,6B;AACA,0B;AACA,6B;AACA,+C;AACA,kB;AACA,Q;AACA,qC;AACA,M;;AAEA,wC;AACA,uB;AACA,4B;AACA,0B;AACA,sC;AACA,gD;AACA,oC;AACA,M;;;;;;;;;;;;;;;;;;;ACnHA,wB;AACA,0B;;AAEA,uE;AACA,wE;;AAEA,mD;AACA,kB;;AAEA,yB;AACA,4C;AACA,6E;;AAEA,mB;AACA,mC;AACA,I;AACA,E;;AAEA,mE;AACA,kD;AACA,W;AACA,4E;AACA,kC;AACA,gF;AACA,wC;AACA,2E;AACA,2E;AACA,0E;AACA,0C;AACA,4E;AACA,4D;AACA,kB;AACA,wE;AACA,oC;AACA,4C;;AAEA,2E;AACA,E;;AAEA,qB;AACA,kE;AACA,yB;;AAEA,gE;AACA,6D;;AAEA,kD;;AAEA,iE;AACA,iC;AACA,4C;AACA,kD;AACA,mC;AACA,wC;AACA,kC;AACA,2D;AACA,mC;AACA,sC;AACA,sD;AACA,2B;AACA,+B;AACA,S;AACA,qB;AACA,+D;AACA,S;AACA,S;AACA,O;AACA,K;;AAEA,iC;AACA,+B;AACA,oE;AACA,6C;AACA,8C;AACA,oC;AACA,qE;AACA,6D;AACA,U;AACA,G;;AAEA,8C;AACA,2B;AACA,gD;AACA,wC;AACA,K;;AAEA,2D;AACA,8D;AACA,K;;AAEA,yB;AACA,wD;AACA,I;AACA,2B;AACA,sC;AACA,kD;AACA,sC;AACA,kD;AACA,e;;AAEA,iB;AACA,kD;;AAEA,yE;AACA,gF;AACA,gF;AACA,6E;AACA,+E;AACA,0B;AACA,I;AACA,gF;AACA,6E;AACA,gF;AACA,4E;AACA,4E;AACA,6E;AACA,gB;AACA,sE;AACA,mE;AACA,+C;AACA,+C;AACA,2D;AACA,O;AACA,S;AACA,gF;AACA,iB;AACA,6B;AACA,2B;AACA,8D;AACA,iB;AACA,qC;AACA,gB;AACA,K;AACA,G;;AAEA,6E;AACA,iE;AACA,a;AACA,S;AACA,+E;AACA,iB;AACA,qC;AACA,gB;AACA,K;AACA,G;;AAEA,6E;AACA,8D;AACA,a;AACA,kD;AACA,+C;AACA,4E;AACA,e;AACA,6E;AACA,G;AACA,U;AACA,6C;AACA,4E;AACA,I;AACA,E;;AAEA,qD;AACA,sB;AACA,2C;AACA,qC;AACA,kC;AACA,kC;AACA,K;AACA,oB;AACA,E;;AAEA,+D;AACA,E;AACA,oE;AACA,wB;AACA,oD;AACA,mB;AACA,mD;AACA,gD;AACA,+C;;AAEA,qB;AACA,0B;;AAEA,8D;;AAEA,2E;AACA,mC;AACA,iC;AACA,0C;AACA,mC;AACA,K;;AAEA,U;AACA,oC;AACA,8B;AACA,+C;AACA,kD;AACA,8B;;AAEA,qD;AACA,sC;AACA,6C;AACA,6D;AACA,6C;AACA,gC;AACA,6C;AACA,8C;;AAEA,mE;;AAEA,mC;AACA,8B;AACA,yD;AACA,iF;AACA,sE;AACA,sE;AACA,0C;AACA,6B;AACA,oB;AACA,8C;AACA,iE;AACA,8C;AACA,a;AACA,kB;AACA,oC;AACA,kE;AACA,0D;AACA,W;AACA,gB;AACA,8B;AACA,kF;AACA,4C;;AAEA,sE;AACA,gC;AACA,2C;AACA,kB;AACA,oC;AACA,8D;AACA,4E;AACA,4C;AACA,kF;AACA,0F;AACA,W;AACA,S;AACA,S;;AAEA,kB;AACA,M;;AAEA,4C;AACA,8B;;AAEA,8B;;AAEA,yD;AACA,4D;AACA,+B;AACA,kC;AACA,iB;AACA,S;;AAEA,yC;AACA,yC;AACA,2D;;AAEA,wE;AACA,qB;AACA,iC;AACA,mB;;AAEA,2C;AACA,0D;;AAEA,4B;AACA,oE;AACA,+B;AACA,2B;AACA,mB;AACA,W;;AAEA,gC;AACA,2D;AACA,8C;AACA,qC;AACA,2B;AACA,mB;AACA,W;;AAEA,0C;AACA,gB;AACA,qD;AACA,uD;;AAEA,8B;AACA,gC;AACA,4D;AACA,wD;;AAEA,yC;AACA,S;AACA,S;;AAEA,kB;AACA,M;;AAEA,kD;AACA,wC;AACA,gD;;AAEA,mB;AACA,qC;AACA,+B;AACA,S;;AAEA,iB;AACA,K;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;AC/TA,2B;;AAEA,4C;;AAEA,gF;AACA,W;AACA,gF;;AAEA,wE;AACA,+E;AACA,mE;AACA,4C;AACA,8C;AACA,2E;AACA,yE;AACA,gD;AACA,kB;AACA,0B;;AAEA,8B;;AAEA,mE;AACA,0B;AACA,+C;AACA,8B;;AAEA,wD;AACA,yB;AACA,E;;AAEA,6E;AACA,kB;;AAEA,mD;;AAEA,8D;AACA,gE;AACA,G;;AAEA,sD;AACA,8C;AACA,U;AACA,sE;AACA,gE;AACA,8D;AACA,yC;AACA,K;AACA,G;;AAEA,yD;AACA,+D;AACA,E;;;;AAIA,mF;AACA,kB;AACA,0D;AACA,E;;AAEA,6B;AACA,mD;AACA,mD;AACA,sC;AACA,kB;;AAEA,sB;AACA,mC;;AAEA,2D;;AAEA,yC;AACA,uC;;AAEA,sC;AACA,6D;AACA,E;;AAEA,mB;AACA,sE;AACA,0E;AACA,8D;AACA,8E;AACA,gE;AACA,wD;AACA,yC;AACA,kB;AACA,kC;AACA,kD;AACA,sB;AACA,iD;AACA,4C;AACA,e;AACA,M;AACA,uD;AACA,gC;AACA,M;AACA,8B;AACA,c;;AAEA,0E;;AAEA,4E;AACA,4E;AACA,8E;AACA,8E;AACA,gF;AACA,2E;AACA,wC;AACA,8B;;AAEA,2D;;AAEA,6C;AACA,mE;AACA,K;;AAEA,4C;AACA,iE;AACA,mD;AACA,uC;AACA,K;;AAEA,6B;AACA,8B;AACA,G;;AAEA,yB;AACA,iD;AACA,G;;AAEA,+B;AACA,8C;AACA,Y;AACA,kC;AACA,oC;AACA,6C;AACA,gC;AACA,M;AACA,I;;AAEA,uD;;AAEA,uB;AACA,2B;AACA,wB;AACA,+E;AACA,iB;AACA,iC;;AAEA,gC;;AAEA,iC;AACA,kC;AACA,K;;AAEA,8E;;AAEA,iC;AACA,uD;AACA,wD;AACA,oE;AACA,Y;AACA,uD;AACA,+E;AACA,8E;AACA,sB;AACA,mD;AACA,S;AACA,K;AACA,G;;AAEA,mC;AACA,kB;AACA,0C;AACA,G;;AAEA,sD;AACA,E;;AAEA,qD;AACA,6B;AACA,iC;AACA,U;AACA,E;;AAEA,Y;AACA,sB;AACA,wB;AACA,uB;AACA,I;AACA,gE;AACA,gC;AACA,kB;;AAEA,2B;AACA,+B;AACA,8B;;AAEA,sD;AACA,8C;AACA,iC;AACA,6B;AACA,+B;AACA,mC;AACA,K;AACA,K;;AAEA,uC;AACA,qE;;AAEA,4D;;AAEA,qB;AACA,wB;AACA,uD;AACA,8D;AACA,+B;AACA,oC;AACA,6B;AACA,uC;AACA,K;AACA,K;;AAEA,yB;AACA,mD;AACA,G;AACA,U;AACA,mB;AACA,2B;AACA,kC;AACA,I;AACA,E;;AAEA,gF;AACA,c;AACA,gF;;AAEA,6D;AACA,kB;;AAEA,sB;AACA,6B;AACA,4C;;AAEA,mB;AACA,8E;AACA,oE;AACA,gF;AACA,uD;AACA,2D;AACA,yB;AACA,4D;AACA,wB;AACA,+D;AACA,E;;AAEA,kD;AACA,kC;AACA,oB;;AAEA,wB;AACA,8C;AACA,a;AACA,K;AACA,iC;AACA,I;AACA,wC;AACA,oB;;AAEA,mD;AACA,gD;AACA,a;AACA,+C;AACA,+E;AACA,K;;AAEA,yD;AACA,I;;AAEA,yB;AACA,oB;AACA,0C;AACA,G;AACA,G;;AAEA,gF;AACA,a;AACA,gF;;AAEA,wB;AACA,yD;AACA,M;AACA,sD;AACA,iE;AACA,kB;;AAEA,sE;;AAEA,0B;AACA,kD;AACA,mE;AACA,qE;AACA,wD;AACA,sD;AACA,E;;AAEA,qE;AACA,kB;AACA,iD;AACA,E;;;AAGA,8D;AACA,gC;AACA,kB;AACA,mD;;AAEA,uC;AACA,iE;AACA,kC;AACA,G;;AAEA,uC;;AAEA,4E;AACA,8E;AACA,kE;AACA,4E;AACA,sE;AACA,8B;AACA,I;AACA,+E;AACA,0E;AACA,6C;AACA,I;AACA,2E;AACA,8E;AACA,8E;AACA,gF;AACA,qE;AACA,yE;AACA,2E;AACA,gF;AACA,4E;AACA,+E;AACA,sE;AACA,oD;AACA,yC;AACA,mC;AACA,gE;AACA,+D;AACA,oC;AACA,oC;AACA,sC;AACA,K;AACA,G;;AAEA,gE;AACA,qC;;AAEA,oC;AACA,wC;AACA,oC;AACA,mD;AACA,+C;AACA,4C;AACA,mD;;AAEA,4D;AACA,qB;AACA,O;;AAEA,uE;AACA,0C;AACA,kE;AACA,qB;AACA,O;;AAEA,4E;AACA,gB;AACA,8E;AACA,qB;AACA,O;;AAEA,kB;AACA,Y;AACA,sD;AACA,K;AACA,K;AACA,E;;AAEA,0E;AACA,8E;AACA,2C;AACA,wD;AACA,kB;AACA,4E;AACA,+C;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;AChZA,gF;AACA,kB;AACA,gF;AACA,0E;AACA,8E;AACA,E;AACA,wE;AACA,gF;AACA,8D;AACA,E;AACA,2E;AACA,4E;AACA,+E;AACA,8B;AACA,6E;AACA,gB;AACA,oD;AACA,kB;;AAEA,a;AACA,4B;AACA,gC;AACA,8C;AACA,U;AACA,iC;AACA,mC;AACA,0C;AACA,G;AACA,E;;AAEA,oE;AACA,kB;AACA,6D;AACA,yC;AACA,E;;AAEA,gF;AACA,kB;AACA,6C;AACA,E;;AAEA,qD;AACA,gE;AACA,kB;;AAEA,yB;AACA,gB;AACA,G;;AAEA,2D;AACA,4D;AACA,8E;AACA,S;AACA,2E;AACA,kB;AACA,mD;AACA,wC;AACA,mE;;AAEA,uE;AACA,2E;AACA,8E;AACA,qC;AACA,oC;AACA,2D;AACA,kE;AACA,0C;AACA,mD;AACA,K;AACA,G;AACA,iB;AACA,E;;AAEA,+E;AACA,kB;AACA,yC;AACA,6C;;AAEA,sB;AACA,qC;AACA,qC;AACA,qB;AACA,kB;AACA,K;AACA,I;;AAEA,mC;AACA,c;AACA,W;AACA,uC;AACA,E;;AAEA,0C;AACA,mE;AACA,kB;AACA,qD;AACA,kD;AACA,qD;AACA,O;AACA,K;AACA,E;;AAEA,sE;AACA,mE;AACA,yB;AACA,kB;;AAEA,uB;;AAEA,yC;AACA,8C;AACA,wB;AACA,mB;AACA,K;AACA,K;;AAEA,mB;AACA,E;;AAEA,mE;AACA,kB;;AAEA,gB;;AAEA,0B;AACA,4B;AACA,K;;AAEA,sB;;AAEA,uD;AACA,E;;;;;;;;;;;;;;;;;;;ACnIA,+B;;AAEA,qD;AACA,kB;AACA,4B;AACA,wC;AACA,uC;AACA,4B;AACA,iC;AACA,2C;AACA,gD;AACA,uC;AACA,4B;AACA,0D;AACA,0C;AACA,8D;AACA,uC;AACA,0C;AACA,oB;AACA,E;;AAEA,mC;AACA,iD;AACA,oB;AACA,mB;AACA,kB;;AAEA,0B;AACA,2D;AACA,oD;AACA,4C;AACA,kB;;AAEA,yB;AACA,sC;AACA,+C;;AAEA,yD;AACA,iB;AACA,gE;AACA,oE;AACA,+B;AACA,6D;AACA,2C;AACA,8B;AACA,uB;AACA,wB;AACA,oE;AACA,kB;AACA,K;;AAEA,qE;AACA,uB;AACA,0D;AACA,yE;AACA,yE;AACA,S;AACA,2C;AACA,iC;AACA,oE;AACA,yC;AACA,0B;AACA,sE;AACA,qD;AACA,oE;AACA,oE;AACA,4E;AACA,wC;AACA,gE;AACA,O;AACA,K;AACA,gB;AACA,I;AACA,+C;AACA,oB;;AAEA,0D;AACA,wD;AACA,kB;AACA,K;;AAEA,yB;;AAEA,yD;AACA,kD;AACA,kB;AACA,K;;AAEA,2E;AACA,sD;AACA,qF;AACA,kC;AACA,wE;AACA,gB;AACA,O;;AAEA,sC;AACA,+B;AACA,8D;AACA,uC;AACA,iB;AACA,6D;AACA,kB;AACA,gD;AACA,kE;AACA,+D;AACA,Y;AACA,sC;AACA,oD;AACA,0C;AACA,K;;AAEA,gB;AACA,I;AACA,qC;AACA,oB;;AAEA,mB;AACA,kB;AACA,4C;AACA,8C;;AAEA,yB;;AAEA,sE;AACA,gC;AACA,4E;AACA,2D;AACA,+D;AACA,K;;AAEA,mD;AACA,yD;AACA,kE;AACA,uC;;AAEA,yE;AACA,e;AACA,oD;AACA,+C;AACA,gE;AACA,O;AACA,iD;AACA,8D;AACA,O;;AAEA,gB;AACA,I;AACA,6E;AACA,Y;AACA,6C;AACA,oB;AACA,oC;AACA,mC;AACA,mE;AACA,0B;AACA,I;AACA,wB;AACA,oB;AACA,4D;AACA,I;AACA,mC;AACA,oB;AACA,8C;AACA,2D;AACA,2D;AACA,2B;AACA,I;AACA,8B;AACA,oB;AACA,kE;AACA,I;AACA,+C;AACA,oB;AACA,0D;AACA,kB;AACA,yB;AACA,gC;AACA,I;AACA,uB;AACA,oB;AACA,wE;AACA,oG;AACA,iC;AACA,O;AACA,iB;AACA,I;AACA,qD;AACA,oB;AACA,gE;AACA,4C;AACA,gD;AACA,oB;AACA,sC;AACA,oB;AACA,I;AACA,6D;AACA,oB;AACA,kF;AACA,wD;AACA,kB;AACA,G;AACA,G;;AAEA,8E;AACA,gF;AACA,0E;AACA,yB;AACA,iC;AACA,wD;AACA,E;;AAEA,0E;AACA,oD;AACA,wC;AACA,uC;AACA,+C;AACA,E;;AAEA,mD;AACA,0D;AACA,yB;AACA,6B;;AAEA,qC;AACA,yE;AACA,oB;AACA,G;;AAEA,gC;AACA,E;;;;;;;;;;;;;;;;;;;ACtOA,6B;AACA,kB;AACA,uC;AACA,sC;AACA,wB;AACA,kC;AACA,2C;AACA,Y;AACA,6B;;AAEA,a;AACA,I;AACA,e;AACA,4C;AACA,+B;AACA,K;;AAEA,4B;AACA,mB;AACA,E;;AAEA,mC;AACA,+B;AACA,oB;AACA,yB;AACA,6B;AACA,2B;AACA,I;AACA,oB;AACA,oB;;AAEA,qB;AACA,4C;;AAEA,uC;AACA,2B;AACA,I;AACA,oB;AACA,oB;;AAEA,qB;AACA,4C;;AAEA,uC;AACA,+B;;AAEA,2B;AACA,0B;;AAEA,gB;AACA,I;AACA,sB;AACA,oB;AACA,8B;AACA,I;AACA,qB;AACA,oB;AACA,6B;AACA,G;AACA,G","file":"/packages/constraint-solver.js","sourcesContent":["ConstraintSolver = {};\n\nvar PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n////////// PackageAndVersion\n\n// An ordered pair of (package, version).\nCS.PackageAndVersion = function (package, version) {\n  check(package, String);\n  check(version, String);\n\n  this.package = package;\n  this.version = version;\n};\n\n// The string form of a PackageAndVersion is \"package version\",\n// for example \"foo 1.0.1\".  The reason we don't use an \"@\" is\n// it would look too much like a PackageConstraint.\nCS.PackageAndVersion.prototype.toString = function () {\n  return this.package + \" \" + this.version;\n};\n\nCS.PackageAndVersion.fromString = function (str) {\n  var parts = str.split(' ');\n  if (parts.length === 2 && parts[0] && parts[1]) {\n    return new CS.PackageAndVersion(parts[0], parts[1]);\n  } else {\n    throw new Error(\"Malformed PackageAndVersion: \" + str);\n  }\n};\n\n////////// Dependency\n\n// A Dependency consists of a PackageConstraint (like \"foo@=1.2.3\")\n// and flags, like \"isWeak\".\n\nCS.Dependency = function (packageConstraint, flags) {\n  check(packageConstraint, Match.OneOf(PV.PackageConstraint, String));\n  if (typeof packageConstraint === 'string') {\n    packageConstraint = PV.parseConstraint(packageConstraint);\n  }\n  if (flags) {\n    check(flags, Object);\n  }\n\n  this.pConstraint = packageConstraint;\n  this.isWeak = false;\n\n  if (flags) {\n    if (flags.isWeak) {\n      this.isWeak = true;\n    }\n  }\n};\n\n// The string form of a Dependency is `?foo@1.0.0` for a weak\n// reference to package \"foo\" with VersionConstraint \"1.0.0\".\nCS.Dependency.prototype.toString = function () {\n  var ret = this.pConstraint.toString();\n  if (this.isWeak) {\n    ret = '?' + ret;\n  }\n  return ret;\n};\n\nCS.Dependency.fromString = function (str) {\n  var isWeak = false;\n\n  if (str.charAt(0) === '?') {\n    isWeak = true;\n    str = str.slice(1);\n  }\n\n  var flags = isWeak ? { isWeak: true } : null;\n\n  return new CS.Dependency(str, flags);\n};\n","var CS = ConstraintSolver;\n\nvar pvkey = function (package, version) {\n  return package + \" \" + version;\n};\n\n// Stores the Dependencies for each known PackageAndVersion.\nCS.CatalogCache = function () {\n  // String(PackageAndVersion) -> String -> Dependency.\n  // For example, \"foo 1.0.0\" -> \"bar\" -> Dependency.fromString(\"?bar@1.0.2\").\n  this._dependencies = {};\n  // A map derived from the keys of _dependencies, for ease of iteration.\n  // \"package\" -> [\"versions\", ...]\n  // Versions in the array are unique but not sorted.\n  this._versions = {};\n};\n\nCS.CatalogCache.prototype.hasPackageVersion = function (package, version) {\n  return _.has(this._dependencies, pvkey(package, version));\n};\n\nCS.CatalogCache.prototype.addPackageVersion = function (p, v, deps) {\n  check(p, String);\n  check(v, String);\n  // `deps` must not have any duplicate values of `.pConstraint.name`\n  check(deps, [CS.Dependency]);\n\n  var key = pvkey(p, v);\n  if (_.has(this._dependencies, key)) {\n    throw new Error(\"Already have an entry for \" + key);\n  }\n\n  if (! _.has(this._versions, p)) {\n    this._versions[p] = [];\n  }\n  this._versions[p].push(v);\n\n  var depsByPackage = {};\n  this._dependencies[key] = depsByPackage;\n  _.each(deps, function (d) {\n    var p2 = d.pConstraint.name;\n    if (_.has(depsByPackage, p2)) {\n      throw new Error(\"Can't have two dependencies on \" + p2 +\n                      \" in \" + key);\n    }\n    depsByPackage[p2] = d;\n  });\n};\n\n// Returns the dependencies of a (package, version), stored in a map.\n// The values are Dependency objects; the key for `d` is\n// `d.pConstraint.name`.  (Don't mutate the map.)\nCS.CatalogCache.prototype.getDependencyMap = function (p, v) {\n  var key = pvkey(p, v);\n  if (! _.has(this._dependencies, key)) {\n    throw new Error(\"No entry for \" + key);\n  }\n  return this._dependencies[key];\n};\n\n// Returns an array of version strings, unsorted, possibly empty.\n// (Don't mutate the result.)\nCS.CatalogCache.prototype.getPackageVersions = function (package) {\n  return (_.has(this._versions, package) ?\n          this._versions[package] : []);\n};\n\nCS.CatalogCache.prototype.toJSONable = function () {\n  var self = this;\n  var data = {};\n  _.each(self._dependencies, function (depsByPackage, key) {\n    // depsByPackage is a map of String -> Dependency.\n    // Map over the values to get an array of String.\n    data[key] = _.map(depsByPackage, function (dep) {\n      return dep.toString();\n    });\n  });\n  return { data: data };\n};\n\nCS.CatalogCache.fromJSONable = function (obj) {\n  check(obj, { data: Object });\n\n  var cache = new CS.CatalogCache();\n  _.each(obj.data, function (depsArray, pv) {\n    check(depsArray, [String]);\n    pv = CS.PackageAndVersion.fromString(pv);\n    cache.addPackageVersion(\n      pv.package, pv.version,\n      _.map(depsArray, function (str) {\n        return CS.Dependency.fromString(str);\n      }));\n  });\n  return cache;\n};\n\n// Calls `iter` on each PackageAndVersion, with the second argument being\n// a map from package name to Dependency.  If `iter` returns true,\n// iteration is stopped.\nCS.CatalogCache.prototype.eachPackageVersion = function (iter) {\n  var self = this;\n  for (var key in self._dependencies) {\n    var stop = iter(CS.PackageAndVersion.fromString(key),\n                    self._dependencies[key]);\n    if (stop) {\n      break;\n    }\n  }\n};\n\n// Calls `iter` on each package name, with the second argument being\n// a list of versions present for that package (unique but not sorted).\n// If `iter` returns true, iteration is stopped.\nConstraintSolver.CatalogCache.prototype.eachPackage = function (iter) {\n  var self = this;\n  for (var key in self._versions) {\n    var stop = iter(key, self.getPackageVersions(key));\n    if (stop) {\n      break;\n    }\n  }\n};\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// A CatalogLoader populates the CatalogCache from the Catalog.  When\n// running unit tests with no Catalog and canned data for the\n// CatalogCache, there will be no CatalogLoader.\n//\n// Fine-grained Loading: While we don't currently support loading only\n// some versions of a package, CatalogLoader is meant to be extended\n// to support incrementally loading individual package versions.  It\n// has no concept of a \"loaded package,\" for example, just a loaded\n// package version.  CatalogLoader's job, in principle, is to load\n// package versions efficiently, no matter the access pattern, by\n// making the right catalog calls and doing the right caching.\n// Calling a catalog method generally means running a SQLite query,\n// which could be time-consuming.\n\nCS.CatalogLoader = function (fromCatalog, toCatalogCache) {\n  var self = this;\n\n  self.catalog = fromCatalog;\n  self.catalogCache = toCatalogCache;\n\n  self._sortedVersionRecordsCache = {};\n};\n\n// We rely on the following `catalog` methods:\n//\n// * getSortedVersionRecords(packageName) ->\n//     [{packageName, version, dependencies}]\n//\n//   Where `dependencies` is a map from packageName to\n//   an object of the form `{ constraint: String|null,\n//   references: [{arch: String, optional \"weak\": true}] }`.\n\nvar convertDeps = function (catalogDeps) {\n  return _.map(catalogDeps, function (dep, package) {\n    // The dependency is strong if any of its \"references\"\n    // (for different architectures) are strong.\n    var isStrong = _.any(dep.references, function (ref) {\n      return !ref.weak;\n    });\n\n    var constraint = (dep.constraint || null);\n    if (constraint === 'none') { // not sure where this comes from\n      constraint = null;\n    }\n\n    return new CS.Dependency(new PV.PackageConstraint(package, constraint),\n                             isStrong ? null : {isWeak: true});\n  });\n};\n\n// Since we don't fetch different versions of a package independently\n// at the moment, this helper is where we get our data.\nCS.CatalogLoader.prototype._getSortedVersionRecords = function (package) {\n  if (! _.has(this._sortedVersionRecordsCache, package)) {\n    this._sortedVersionRecordsCache[package] =\n      this.catalog.getSortedVersionRecords(package);\n  }\n\n  return this._sortedVersionRecordsCache[package];\n};\n\nCS.CatalogLoader.prototype.loadAllVersions = function (package) {\n  var self = this;\n  var cache = self.catalogCache;\n  var versionRecs = self._getSortedVersionRecords(package);\n  _.each(versionRecs, function (rec) {\n    var version = rec.version;\n    if (! cache.hasPackageVersion(package, version)) {\n      var deps = convertDeps(rec.dependencies);\n      cache.addPackageVersion(package, version, deps);\n    }\n  });\n};\n\n// Takes an array of package names.  Loads all versions of them and their\n// (strong) dependencies.\nCS.CatalogLoader.prototype.loadAllVersionsRecursive = function (packageList) {\n  var self = this;\n\n  // Within a call to loadAllVersionsRecursive, we only visit each package\n  // at most once.  If we visit a package we've already loaded, it will\n  // lead to a quick scan through the versions in our cache to make sure\n  // they have been loaded into the CatalogCache.\n  var loadQueue = [];\n  var packagesEverEnqueued = {};\n\n  var enqueue = function (package) {\n    if (! _.has(packagesEverEnqueued, package)) {\n      packagesEverEnqueued[package] = true;\n      loadQueue.push(package);\n    }\n  };\n\n  _.each(packageList, enqueue);\n\n  while (loadQueue.length) {\n    var package = loadQueue.pop();\n    self.loadAllVersions(package);\n    _.each(self.catalogCache.getPackageVersions(package), function (v) {\n      var depMap = self.catalogCache.getDependencyMap(package, v);\n      _.each(depMap, function (dep, package2) {\n        enqueue(package2);\n      });\n    });\n  }\n};\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// The \"Input\" object completely specifies the input to the resolver,\n// and it holds the data loaded from the Catalog as well.  It can be\n// serialized to JSON and read back in for testing purposes.\nCS.Input = function (dependencies, constraints, catalogCache, options) {\n  options = options || {};\n\n  this.dependencies = dependencies;\n  this.constraints = constraints;\n  this.upgrade = options.upgrade || [];\n  this.anticipatedPrereleases = options.anticipatedPrereleases || {};\n  this.previousSolution = options.previousSolution || null;\n\n  check(this.dependencies, [String]);\n  check(this.constraints, [PackageConstraintType]);\n  check(this.upgrade, [String]);\n  check(this.anticipatedPrereleases,\n        Match.ObjectWithValues(Match.ObjectWithValues(Boolean)));\n  check(this.previousSolution, Match.OneOf(Object, null));\n\n  this.catalogCache = catalogCache;\n};\n\nCS.Input.prototype.loadFromCatalog = function (catalogLoader) {\n  var self = this;\n\n  var packagesToLoad = {}; // package -> true\n\n  _.each(self.dependencies, function (package) {\n    packagesToLoad[package] = true;\n  });\n  _.each(self.constraints, function (constraint) {\n    packagesToLoad[constraint.name] = true;\n  });\n  _.each(self.previousSolution, function (version, package) {\n    packagesToLoad[package] = true;\n  });\n\n  // Load packages into the cache (if they aren't loaded already).\n  catalogLoader.loadAllVersionsRecursive(_.keys(packagesToLoad));\n};\n\nCS.Input.prototype.toJSONable = function () {\n  var self = this;\n  var obj = {\n    dependencies: self.dependencies,\n    constraints: _.map(self.constraints, function (c) {\n      return c.toString();\n    }),\n    catalogCache: self.catalogCache.toJSONable()\n  };\n  // For readability of the resulting JSON, only include optional\n  // properties that aren't the default.\n  if (self.upgrade.length) {\n    obj.upgrade = self.upgrade;\n  }\n  if (! _.isEmpty(self.anticipatedPrereleases)) {\n    obj.anticipatedPrereleases = self.anticipatedPrereleases;\n  }\n  if (self.previousSolution !== null) {\n    obj.previousSolution = self.previousSolution;\n  };\n  return obj;\n};\n\nCS.Input.fromJSONable = function (obj) {\n  check(obj, {\n    dependencies: [String],\n    constraints: [String],\n    catalogCache: Object,\n    anticipatedPrereleases: Match.Optional(\n      Match.ObjectWithValues(Match.ObjectWithValues(Boolean))),\n    previousSolution: Match.Optional(Match.OneOf(Object, null)),\n    upgrade: Match.Optional([String])\n  });\n\n  return new CS.Input(\n    obj.dependencies,\n    _.map(obj.constraints, function (cstr) {\n      return PV.parseConstraint(cstr);\n    }),\n    CS.CatalogCache.fromJSONable(obj.catalogCache),\n    {\n      upgrade: obj.upgrade,\n      anticipatedPrereleases: obj.anticipatedPrereleases,\n      previousSolution: obj.previousSolution\n    });\n};\n\n// PackageConstraints and VersionConstraints passed in from the tool\n// to us (where we are a uniloaded package) will have constructors\n// that we don't recognize because they come from a different copy of\n// package-version-parser!  In addition, objects with constructors\n// can't be checked by \"check\" in the same way as plain objects, so we\n// have to resort to examining the fields explicitly.\nvar VersionConstraintType = Match.OneOf(\n  PV.VersionConstraint,\n  Match.Where(function (vc) {\n    check(vc.raw, String);\n    check(vc.alternatives, [{\n      versionString: Match.OneOf(String, null),\n      type: String\n    }]);\n    return vc.constructor !== Object;\n  }));\n\nvar PackageConstraintType = Match.OneOf(\n  PV.PackageConstraint,\n  Match.Where(function (c) {\n    check(c.name, String);\n    check(c.constraintString, String);\n    check(c.vConstraint, VersionConstraintType);\n    return c.constructor !== Object;\n  }));\n","var PV = PackageVersion;\nvar CS = ConstraintSolver;\n\n// This is the entry point for the constraint-solver package.  The tool\n// creates a ConstraintSolver.PackagesResolver and calls .resolve on it.\n\nCS.PackagesResolver = function (catalog, options) {\n  var self = this;\n\n  self.catalog = catalog;\n  self.catalogCache = new CS.CatalogCache();\n  self.catalogLoader = new CS.CatalogLoader(self.catalog, self.catalogCache);\n\n  self._options = {\n    nudge: options && options.nudge\n  };\n};\n\n// dependencies - an array of string names of packages (not slices)\n// constraints - an array of PV.PackageConstraints\n// options:\n//  - upgrade - list of dependencies for which upgrade is prioritized higher\n//    than keeping the old version\n//  - previousSolution - mapping from package name to a version that was used in\n//    the previous constraint solver run\n//  - anticipatedPrereleases: mapping from package name to version to true;\n//    included versions are the only pre-releases that are allowed to match\n//    constraints that don't specifically name them during the \"try not to\n//    use unanticipated pre-releases\" pass\nCS.PackagesResolver.prototype.resolve = function (dependencies, constraints,\n                                                  options) {\n  var self = this;\n  var input = new CS.Input(dependencies, constraints, self.catalogCache,\n                           options);\n  input.loadFromCatalog(self.catalogLoader);\n\n  return CS.PackagesResolver._resolveWithInput(input, this._options.nudge);\n};\n\n// Exposed for tests.\nCS.PackagesResolver._resolveWithInput = function (input, _nudge) {\n  check(input, CS.Input);\n\n  // Dump the input to the console!  XXX Put this behind a flag.\n  //console.log(JSON.stringify(input.toJSONable(), null, 2));\n\n  var resolver = new CS.Resolver({nudge: _nudge});\n\n  // Set up the Resolver using the package versions in the cache.\n  var cache = input.catalogCache;\n  cache.eachPackage(function (p, versions) {\n    versions = _.clone(versions).sort(PV.compare);\n    _.each(versions, function (v) {\n      var uv = new CS.UnitVersion(p, v);\n      resolver.addUnitVersion(uv);\n      _.each(cache.getDependencyMap(p, v), function (dep) {\n        // `dep` is a CS.Dependency\n        var p2 = dep.pConstraint.name;\n        var constr = dep.pConstraint.constraintString;\n        if (! dep.isWeak) {\n          uv.addDependency(p2);\n        }\n        if (constr) {\n          uv.addConstraint(resolver.getConstraint(p2, constr));\n        }\n      });\n    });\n  });\n\n  var previousSolutionUVs = null;\n  if (input.previousSolution) {\n    // Build a list of the UnitVersions that we know about that were\n    // mentioned in the previousSolution map.\n    // (_.compact drops unknown UnitVersions.)\n    previousSolutionUVs = _.compact(\n      _.map(input.previousSolution, function (version, packageName) {\n        return resolver.getUnitVersion(packageName, version);\n      }));\n  }\n\n  // Convert upgrade to a map for O(1) access.\n  var upgradePackages = {};\n  _.each(input.upgrade, function (packageName) {\n    upgradePackages[packageName] = true;\n  });\n\n  var constraints = _.map(input.constraints, function (c) {\n    return resolver.getConstraint(c.name, c.constraintString);\n  });\n\n  var resolverOptions = {\n    anticipatedPrereleases: input.anticipatedPrereleases\n  };\n  _.extend(resolverOptions,\n           getCostFunction(resolver, {\n             rootDependencies: input.dependencies,\n             upgrade: upgradePackages,\n             previousSolution: previousSolutionUVs\n           }));\n\n  var res = null;\n  var neededToUseUnanticipatedPrereleases = false;\n\n  // If a previous solution existed, try resolving with additional (weak)\n  // equality constraints on all the versions from the previous solution (except\n  // those we've explicitly been asked to update). If it's possible to solve the\n  // constraints without changing any of the previous versions (though we may\n  // add more choices in addition, or remove some now-unnecessary choices) then\n  // that's our first try.\n  //\n  // If we're intentionally trying to upgrade some or all packages, we just skip\n  // this step. We used to try to do this step but just leaving off pins from\n  // the packages we're trying to upgrade, but this tended to not lead to actual\n  // upgrades since we were still pinning things that the to-upgrade package\n  // depended on.  (We still use the specific contents of options.upgrade to\n  // guide which things are encouraged to be upgraded vs stay the same in the\n  // heuristic.)\n  if (!_.isEmpty(previousSolutionUVs) && _.isEmpty(upgradePackages)) {\n    var constraintsWithPreviousSolutionLock = _.clone(constraints);\n    _.each(previousSolutionUVs, function (uv) {\n      constraintsWithPreviousSolutionLock.push(\n        resolver.getConstraint(uv.name, '=' + uv.version));\n    });\n    try {\n      // Try running the resolver. If it fails to resolve, that's OK, we'll keep\n      // working.\n      res = resolver.resolve(\n        input.dependencies,\n        constraintsWithPreviousSolutionLock, resolverOptions);\n    } catch (e) {\n      if (!(e.constraintSolverError))\n        throw e;\n    }\n  }\n\n  // Either we didn't have a previous solution, or it doesn't work. Try again\n  // without locking in the previous solution as strict equality.\n  if (!res) {\n    try {\n      res = resolver.resolve(input.dependencies, constraints, resolverOptions);\n    } catch (e) {\n      if (!(e.constraintSolverError))\n        throw e;\n    }\n  }\n\n  // As a last-ditch effort, let's allow ANY pre-release version found in the\n  // catalog, not only those that are asked for at some level.\n  if (!res) {\n    resolverOptions.anticipatedPrereleases = true;\n    neededToUseUnanticipatedPrereleases = true;\n    // Unlike the previous calls, this one throws a constraintSolverError on\n    // failure.\n    res = resolver.resolve(input.dependencies, constraints, resolverOptions);\n  }\n  return {\n    answer:  resolverResultToPackageMap(res),\n    neededToUseUnanticipatedPrereleases: neededToUseUnanticipatedPrereleases\n  };\n};\n\nvar resolverResultToPackageMap = function (choices) {\n  var packageMap = {};\n  mori.each(choices, function (nameAndUv) {\n    var name = mori.first(nameAndUv);\n    var uv = mori.last(nameAndUv);\n    packageMap[name] = uv.version;\n  });\n  return packageMap;\n};\n\n// Takes options {rootDependencies, previousSolution, upgrade}.\n//\n// Returns an object containing {costFunction, estimateCostFunction,\n// combineCostFunction}.\nvar getCostFunction = function (resolver, options) {\n  // Poorman's enum\n  var VMAJOR = 0, MAJOR = 1, MEDIUM = 2, MINOR = 3;\n  var rootDeps = options.rootDependencies || [];\n  var prevSol = options.previousSolution || [];\n\n  var isRootDep = {};\n  var prevSolMapping = {};\n\n  _.each(rootDeps, function (dep) { isRootDep[dep] = true; });\n\n  // if the upgrade is preferred over preserving previous solution, pretend\n  // there are no previous solution\n  _.each(prevSol, function (uv) {\n    if (! _.has(options.upgrade, uv.name))\n      prevSolMapping[uv.name] = uv;\n  });\n\n  return {\n    costFunction: function (state) {\n      options = options || {};\n      // very major, major, medium, minor costs\n      // XXX maybe these can be calculated lazily?\n      var cost = [0, 0, 0, 0];\n\n      mori.each(state.choices, function (nameAndUv) {\n        var uv = mori.last(nameAndUv);\n        if (_.has(prevSolMapping, uv.name)) {\n          // The package was present in the previous solution\n          var prev = prevSolMapping[uv.name];\n          var versionsDistance =\n            PV.versionMagnitude(uv.version) -\n            PV.versionMagnitude(prev.version);\n\n          var isCompatible = prev.majorVersion === uv.majorVersion;\n\n          if (isRootDep[uv.name]) {\n            // root dependency\n            if (versionsDistance < 0 || ! isCompatible) {\n              // the new pick is older or is incompatible with the prev. solution\n              // i.e. can have breaking changes, prefer not to do this\n              // XXX in fact we want to avoid downgrades to the direct\n              // dependencies at all cost.\n              cost[VMAJOR]++;\n            } else {\n              // compatible but possibly newer\n              // prefer the version closest to the older solution\n              cost[MAJOR] += versionsDistance;\n            }\n          } else {\n            // transitive dependency\n            // prefer to have less changed transitive dependencies\n            cost[MINOR] += versionsDistance === 0 ? 0 : 1;\n          }\n        } else {\n          var latestDistance =\n            PV.versionMagnitude(_.last(resolver.unitsVersions[uv.name]).version) -\n            PV.versionMagnitude(uv.version);\n\n          if (isRootDep[uv.name] || _.has(options.upgrade, uv.name)) {\n            // preferably latest\n            cost[MEDIUM] += latestDistance;\n          } else {\n            // transitive dependency\n            // prefarable earliest possible to be conservative\n            // How far is our choice from the most conservative version that\n            // also matches our constraints?\n            var minimal = state.constraints.getMinimalVersion(uv.name) || '0.0.0';\n            cost[MINOR] += PV.versionMagnitude(uv.version) - PV.versionMagnitude(minimal);\n          }\n        }\n      });\n\n      return cost;\n    },\n\n    estimateCostFunction: function (state) {\n      options = options || {};\n\n      var cost = [0, 0, 0, 0];\n\n      state.eachDependency(function (dep, alternatives) {\n        // XXX don't try to estimate transitive dependencies\n        if (! isRootDep[dep]) {\n          cost[MINOR] += 10000000;\n          return;\n        }\n\n        if (_.has(prevSolMapping, dep)) {\n          var prev = prevSolMapping[dep];\n          var prevVersionMatches = state.isSatisfied(prev);\n\n          // if it matches, assume we would pick it and the cost doesn't\n          // increase\n          if (prevVersionMatches)\n            return;\n\n          // Get earliest matching version.\n          var earliestMatching = mori.first(alternatives);\n\n          var isCompatible =\n                prev.majorVersion === earliestMatching.majorVersion;\n          if (! isCompatible) {\n            cost[VMAJOR]++;\n            return;\n          }\n\n          var versionsDistance =\n            PV.versionMagnitude(earliestMatching.version) -\n            PV.versionMagnitude(prev.version);\n          if (versionsDistance < 0) {\n            cost[VMAJOR]++;\n            return;\n          }\n\n          cost[MAJOR] += versionsDistance;\n        } else {\n          var versions = resolver.unitsVersions[dep];\n          var latestMatching = mori.last(alternatives);\n\n          var latestDistance =\n            PV.versionMagnitude(\n              _.last(resolver.unitsVersions[dep]).version) -\n            PV.versionMagnitude(latestMatching.version);\n\n          cost[MEDIUM] += latestDistance;\n        }\n      });\n\n      return cost;\n    },\n\n    combineCostFunction: function (costA, costB) {\n      if (costA.length !== costB.length)\n        throw new Error(\"Different cost types\");\n\n      var arr = [];\n      _.each(costA, function (l, i) {\n        arr.push(l + costB[i]);\n      });\n\n      return arr;\n    }\n  };\n};\n","mori = Npm.require('mori');\n\nBREAK = {};  // used by our 'each' functions\n\n////////////////////////////////////////////////////////////////////////////////\n// Resolver\n////////////////////////////////////////////////////////////////////////////////\n\n// XXX the whole resolver heavily relies on these statements to be true:\n// - every unit version ever used was added to the resolver with addUnitVersion\n// - every constraint ever used was instantiated with getConstraint\n// - every constraint was added exactly once\n// - every unit version was added exactly once\n// - if two unit versions are the same, their refs point at the same object\n// - if two constraints are the same, their refs point at the same object\nConstraintSolver.Resolver = function (options) {\n  var self = this;\n  options = options || {};\n\n  self._nudge = options.nudge;\n\n  // Maps unit name string to a sorted array of version definitions\n  self.unitsVersions = {};\n  // Maps name@version string to a unit version\n  self._unitsVersionsMap = {};\n\n  // Refs to all constraints. Mapping String -> instance\n  self._constraints = {};\n};\n\nConstraintSolver.Resolver.prototype.addUnitVersion = function (unitVersion) {\n  var self = this;\n\n  check(unitVersion, ConstraintSolver.UnitVersion);\n\n  if (_.has(self._unitsVersionsMap, unitVersion.toString())) {\n    throw Error(\"duplicate uv \" + unitVersion.toString() + \"?\");\n  }\n\n  if (! _.has(self.unitsVersions, unitVersion.name)) {\n    self.unitsVersions[unitVersion.name] = [];\n  } else {\n    var latest = _.last(self.unitsVersions[unitVersion.name]).version;\n    if (!PackageVersion.lessThan(latest, unitVersion.version)) {\n      throw Error(\"adding uv out of order: \" + latest + \" vs \"\n                  + unitVersion.version);\n    }\n  }\n\n  self.unitsVersions[unitVersion.name].push(unitVersion);\n  self._unitsVersionsMap[unitVersion.toString()] = unitVersion;\n};\n\n\n\nConstraintSolver.Resolver.prototype.getUnitVersion = function (unitName, version) {\n  var self = this;\n  return self._unitsVersionsMap[unitName + \"@\" + version];\n};\n\n// name - String - \"someUnit\"\n// versionConstraint - String - \"=1.2.3\" or \"2.1.0\"\nConstraintSolver.Resolver.prototype.getConstraint =\n  function (name, versionConstraint) {\n  var self = this;\n\n  check(name, String);\n  check(versionConstraint, String);\n\n  var idString = JSON.stringify([name, versionConstraint]);\n\n  if (_.has(self._constraints, idString))\n    return self._constraints[idString];\n\n  return self._constraints[idString] =\n    new ConstraintSolver.Constraint(name, versionConstraint);\n};\n\n// options: Object:\n// - costFunction: function (state) - given a state evaluates its cost\n// - estimateCostFunction: function (state) - given a state, evaluates the\n// estimated cost of the best path from state to a final state\n// - combineCostFunction: function (cost, cost) - given two costs (obtained by\n// evaluating states with costFunction and estimateCostFunction)\nConstraintSolver.Resolver.prototype.resolve = function (\n    dependencies, constraints, options) {\n  var self = this;\n  constraints = constraints || [];\n  var choices = mori.hash_map();  // uv.name -> uv\n  options = _.extend({\n    costFunction: function (state) { return 0; },\n    estimateCostFunction: function (state) {\n      return 0;\n    },\n    combineCostFunction: function (cost, anotherCost) {\n      return cost + anotherCost;\n    },\n    anticipatedPrereleases: {}\n  }, options);\n\n  var resolveContext = new ResolveContext(options.anticipatedPrereleases);\n\n  // Mapping that assigns every package an integer priority. We compute this\n  // dynamically and in the process of resolution we try to resolve packages\n  // with higher priority first. This helps the resolver a lot because if some\n  // package has a higher weight to the solution (like a direct dependency) or\n  // is more likely to break our solution in the future than others, it would be\n  // great to try out and evaluate all versions early in the decision tree.\n  // XXX this could go on ResolveContext\n  var resolutionPriority = {};\n\n  var startState = new ResolverState(self, resolveContext);\n\n  _.each(constraints, function (constraint) {\n    startState = startState.addConstraint(constraint, mori.list());\n  });\n\n  _.each(dependencies, function (unitName) {\n    startState = startState.addDependency(unitName, mori.list());\n    // Direct dependencies start on higher priority\n    resolutionPriority[unitName] = 100;\n  });\n\n  if (startState.success()) {\n    return startState.choices;\n  }\n\n  if (startState.error) {\n    throwConstraintSolverError(startState.error);\n  }\n\n  var pq = new PriorityQueue();\n  var overallCostFunction = function (state) {\n    return [\n      options.combineCostFunction(\n        options.costFunction(state),\n        options.estimateCostFunction(state)),\n      -mori.count(state.choices)\n    ];\n  };\n\n  pq.push(startState, overallCostFunction(startState));\n\n  var someError = null;\n  var anySucceeded = false;\n  while (! pq.empty()) {\n    // Since we're in a CPU-bound loop, allow yielding or printing a message or\n    // something.\n    self._nudge && self._nudge();\n\n    var currentState = pq.pop();\n\n    if (currentState.success()) {\n      return currentState.choices;\n    }\n\n    var neighborsObj = self._stateNeighbors(currentState, resolutionPriority);\n\n    if (! neighborsObj.success) {\n      someError = someError || neighborsObj.failureMsg;\n      resolutionPriority[neighborsObj.conflictingUnit] =\n        (resolutionPriority[neighborsObj.conflictingUnit] || 0) + 1;\n    } else {\n      _.each(neighborsObj.neighbors, function (state) {\n        // We don't just return the first successful one we find, in case there\n        // are multiple successful states (we want to sort by cost function in\n        // that case).\n        pq.push(state, overallCostFunction(state));\n      });\n    }\n  }\n\n  // XXX should be much much better\n  if (someError) {\n    throwConstraintSolverError(someError);\n  }\n\n  throw new Error(\"ran out of states without error?\");\n};\n\nvar throwConstraintSolverError = function (message) {\n  var e = new Error(message);\n  e.constraintSolverError = true;\n  throw e;\n};\n\n// returns {\n//   success: Boolean,\n//   failureMsg: String,\n//   neighbors: [state]\n// }\nConstraintSolver.Resolver.prototype._stateNeighbors = function (\n    state, resolutionPriority) {\n  var self = this;\n\n  var candidateName = null;\n  var candidateVersions = null;\n  var currentNaughtiness = -1;\n\n  state.eachDependency(function (unitName, versions) {\n    var r = resolutionPriority[unitName] || 0;\n    if (r > currentNaughtiness) {\n      currentNaughtiness = r;\n      candidateName = unitName;\n      candidateVersions = versions;\n    }\n  });\n\n  if (mori.is_empty(candidateVersions))\n    throw Error(\"empty candidate set? should have detected earlier\");\n\n  var pathway = state.somePathwayForUnitName(candidateName);\n\n  var neighbors = [];\n  var firstError = null;\n  mori.each(candidateVersions, function (unitVersion) {\n    var neighborState = state.addChoice(unitVersion, pathway);\n    if (!neighborState.error) {\n      neighbors.push(neighborState);\n    } else if (!firstError) {\n      firstError = neighborState.error;\n    }\n  });\n\n  if (neighbors.length) {\n    return { success: true, neighbors: neighbors };\n  }\n  return {\n    success: false,\n    failureMsg: firstError,\n    conflictingUnit: candidateName\n  };\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// UnitVersion\n////////////////////////////////////////////////////////////////////////////////\n\nConstraintSolver.UnitVersion = function (name, unitVersion) {\n  var self = this;\n\n  check(name, String);\n  check(unitVersion, String);\n  check(self, ConstraintSolver.UnitVersion);\n\n  self.name = name;\n  // Things with different build IDs should represent the same code, so ignore\n  // them. (Notably: depending on @=1.3.1 should allow 1.3.1+local!)\n  // XXX we no longer automatically add build IDs to things as part of our build\n  // process, but this still reflects semver semantics.\n  self.version = PackageVersion.removeBuildID(unitVersion);\n  self.dependencies = [];\n  self.constraints = new ConstraintSolver.ConstraintsList();\n  // integer like 1 or 2\n  self.majorVersion = PackageVersion.majorVersion(unitVersion);\n};\n\n_.extend(ConstraintSolver.UnitVersion.prototype, {\n  addDependency: function (name) {\n    var self = this;\n\n    check(name, String);\n    if (_.contains(self.dependencies, name)) {\n      return;\n    }\n    self.dependencies.push(name);\n  },\n  addConstraint: function (constraint) {\n    var self = this;\n\n    check(constraint, ConstraintSolver.Constraint);\n    if (self.constraints.contains(constraint)) {\n      return;\n      // XXX may also throw if it is unexpected\n      throw new Error(\"Constraint already exists -- \" + constraint.toString());\n    }\n\n    self.constraints = self.constraints.push(constraint);\n  },\n\n  toString: function () {\n    var self = this;\n    return self.name + \"@\" + self.version;\n  }\n});\n\n////////////////////////////////////////////////////////////////////////////////\n// Constraint\n////////////////////////////////////////////////////////////////////////////////\n\n// Can be called either:\n//    new PackageVersion.Constraint(\"packageA\", \"=2.1.0\")\n// or:\n//    new PackageVersion.Constraint(\"pacakgeA@=2.1.0\")\nConstraintSolver.Constraint = function (name, constraintString) {\n  var self = this;\n\n  var parsed = PackageVersion.parseConstraint(name, constraintString);\n\n  self.name = parsed.name;\n  self.constraintString = parsed.constraintString;\n  // The results of parsing are `||`-separated alternatives, simple\n  // constraints like `1.0.0` or `=1.0.1` which have been parsed into\n  // objects with a `type` and `versionString` property.\n  self.alternatives = parsed.vConstraint.alternatives;\n};\n\nConstraintSolver.Constraint.prototype.toString = function (options) {\n  var self = this;\n  return self.name + \"@\" + self.constraintString;\n};\n\n\nConstraintSolver.Constraint.prototype.isSatisfied = function (\n  candidateUV, resolveContext) {\n  var self = this;\n  check(candidateUV, ConstraintSolver.UnitVersion);\n\n  if (self.name !== candidateUV.name) {\n    throw Error(\"asking constraint on \" + self.name + \" about \" +\n                candidateUV.name);\n  }\n\n  var prereleaseNeedingLicense = false;\n\n  // We try not to allow \"pre-release\" versions (versions with a '-') unless\n  // they are explicitly mentioned.  If the `anticipatedPrereleases` option is\n  // `true` set, all pre-release versions are allowed.  Otherwise,\n  // anticipatedPrereleases lists pre-release versions that are always allow\n  // (this corresponds to pre-release versions mentioned explicitly in\n  // *top-level* constraints).\n  //\n  // Otherwise, if `candidateUV` is a pre-release, it needs to be \"licensed\" by\n  // being mentioned by name in *this* constraint or matched by an inexact\n  // constraint whose version also has a '-'.\n  //\n  // Note that a constraint \"@2.0.0\" can never match a version \"2.0.1-rc.1\"\n  // unless anticipatedPrereleases allows it, even if another constraint found\n  // in the graph (but not at the top level) explicitly mentions \"2.0.1-rc.1\".\n  // Why? The constraint solver assumes that adding a constraint to the resolver\n  // state can't make previously impossible choices now possible.  If\n  // pre-releases mentioned anywhere worked, then applying the constraint\n  // \"@2.0.0\" followed by \"@=2.0.1-rc.1\" would result in \"2.0.1-rc.1\" ruled\n  // first impossible and then possible again. That will break this algorith, so\n  // we have to fix the meaning based on something known at the start of the\n  // search.  (We could try to apply our prerelease-avoidance tactics solely in\n  // the cost functions, but then it becomes a much less strict rule.)\n  if (resolveContext.anticipatedPrereleases !== true\n      && /-/.test(candidateUV.version)) {\n    var isAnticipatedPrerelease = (\n      _.has(resolveContext.anticipatedPrereleases, self.name) &&\n        _.has(resolveContext.anticipatedPrereleases[self.name],\n              candidateUV.version));\n    if (! isAnticipatedPrerelease) {\n      prereleaseNeedingLicense = true;\n    }\n  }\n\n  return _.some(self.alternatives, function (simpleConstraint) {\n    var type = simpleConstraint.type;\n\n    if (type === \"any-reasonable\") {\n      return ! prereleaseNeedingLicense;\n    } else if (type === \"exactly\") {\n      var version = simpleConstraint.versionString;\n      return (version === candidateUV.version);\n    } else if (type === 'compatible-with') {\n      var version = simpleConstraint.versionString;\n\n      if (prereleaseNeedingLicense && ! /-/.test(version)) {\n        return false;\n      }\n\n      // If the candidate version is less than the version named in the\n      // constraint, we are not satisfied.\n      if (PackageVersion.lessThan(candidateUV.version, version)) {\n        return false;\n      }\n\n      // To be compatible, the two versions must have the same major version\n      // number.\n      if (candidateUV.majorVersion !== PackageVersion.majorVersion(version)) {\n        return false;\n      }\n\n      return true;\n    } else {\n      throw Error(\"Unknown constraint type: \" + type);\n    }\n  });\n};\n\n// An object that records the general context of a resolve call. It can be\n// different for different resolve calls on the same Resolver, but is the same\n// for every ResolverState in a given call.\nvar ResolveContext = function (anticipatedPrereleases) {\n  var self = this;\n  // EITHER: \"true\", in which case all prereleases are anticipated, or a map\n  //         unitName -> version string -> true\n  self.anticipatedPrereleases = anticipatedPrereleases;\n};\n","////////////////////////////////////////////////////////////////////////////////\n// ConstraintsList\n////////////////////////////////////////////////////////////////////////////////\n// A persistent data-structure that keeps references to Constraint objects\n// arranged by the \"name\" field of Constraint and exactness of the constraint.\n//\n// Internal structure has two maps, 'exact' and 'inexact'; they each map\n// unit name -> mori.set(Constraint).  (This relies on the fact that Constraints\n// are interned, so that mori.set can use reference identity.)\n//\n// We separate the constraints by exactness so that the iteration functions\n// (forPackage and each) can easily provide exact constraints before inexact\n// constraints, because exact constraints generally help the consumer pare down\n// their possibilities faster.\n// XXX This is just a theory, and it's not clear that we have benchmarks that\n//     prove it.\nConstraintSolver.ConstraintsList = function (prev) {\n  var self = this;\n\n  if (prev) {\n    self.exact = prev.exact;\n    self.inexact = prev.inexact;\n    self.minimalVersion = prev.minimalVersion;\n  } else {\n    self.exact = mori.hash_map();\n    self.inexact = mori.hash_map();\n    self.minimalVersion = mori.hash_map();\n  }\n};\n\nConstraintSolver.ConstraintsList.prototype.contains = function (c) {\n  var self = this;\n  var map = c.type === 'exactly' ? self.exact : self.inexact;\n  return !!mori.get_in(map, [c.name, c]);\n};\n\nConstraintSolver.ConstraintsList.prototype.getMinimalVersion = function (name) {\n  var self = this;\n  return mori.get(self.minimalVersion, name);\n};\n\n// returns a new version containing passed constraint\nConstraintSolver.ConstraintsList.prototype.push = function (c) {\n  var self = this;\n\n  if (self.contains(c)) {\n    return self;\n  }\n\n  var newList = new ConstraintSolver.ConstraintsList(self);\n  var mapField = c.type === 'exactly' ? 'exact' : 'inexact';\n  // Get the current constraints on this package of the exactness, or an empty\n  // set.\n  var currentConstraints = mori.get(newList[mapField], c.name, mori.set());\n  // Add this one.\n  newList[mapField] = mori.assoc(newList[mapField],\n                                 c.name,\n                                 mori.conj(currentConstraints, c));\n\n  // Maintain the \"minimal version\" that can satisfy these constraints.\n  // Note that this is one of the only pieces of the constraint solver that\n  // actually does logic on constraints (and thus relies on the restricted set\n  // of constraints that we support).\n  if (c.type !== 'any-reasonable') {\n    var minimal = mori.get(newList.minimalVersion, c.name);\n    if (!minimal || PackageVersion.lessThan(c.version, minimal)) {\n      newList.minimalVersion = mori.assoc(\n        newList.minimalVersion, c.name, c.version);\n    }\n  }\n  return newList;\n};\n\nConstraintSolver.ConstraintsList.prototype.forPackage = function (name, iter) {\n  var self = this;\n  var exact = mori.get(self.exact, name);\n  var inexact = mori.get(self.inexact, name);\n\n  var breaked = false;\n  var niter = function (constraint) {\n    if (iter(constraint) === BREAK) {\n      breaked = true;\n      return true;\n    }\n  };\n\n  exact && mori.some(niter, exact);\n  if (breaked)\n    return;\n  inexact && mori.some(niter, inexact);\n};\n\n// doesn't break on the false return value\nConstraintSolver.ConstraintsList.prototype.each = function (iter) {\n  var self = this;\n  _.each([self.exact, self.inexact], function (map) {\n    mori.each(map, function (nameAndConstraints) {\n      mori.each(mori.last(nameAndConstraints), iter);\n    });\n  });\n};\n\n// Checks if the passed unit version satisfies all of the constraints.\nConstraintSolver.ConstraintsList.prototype.isSatisfied = function (\n    uv, resolveContext) {\n  var self = this;\n\n  var satisfied = true;\n\n  self.forPackage(uv.name, function (c) {\n    if (! c.isSatisfied(uv, resolveContext)) {\n      satisfied = false;\n      return BREAK;\n    }\n  });\n\n  return satisfied;\n};\n\nConstraintSolver.ConstraintsList.prototype.toString = function () {\n  var self = this;\n\n  var strs = [];\n\n  self.each(function (c) {\n    strs.push(c.toString());\n  });\n\n  strs = _.uniq(strs);\n\n  return \"<constraints list: \" + strs.join(\", \") + \">\";\n};\n","var util = Npm.require('util');\n\nResolverState = function (resolver, resolveContext) {\n  var self = this;\n  self._resolver = resolver;\n  self._resolveContext = resolveContext;\n  // The versions we've already chosen.\n  // unitName -> UnitVersion\n  self.choices = mori.hash_map();\n  // Units we need, but haven't chosen yet.\n  // unitName -> sorted vector of (UnitVersions)\n  self._dependencies = mori.hash_map();\n  // Constraints that apply.\n  self.constraints = new ConstraintSolver.ConstraintsList;\n  // How we've decided things about units.\n  // unitName -> set(list (reversed) of UVs that led us here).\n  self._unitPathways = mori.hash_map();\n  // If we've already hit a contradiction.\n  self.error = null;\n};\n\n_.extend(ResolverState.prototype, {\n  addConstraint: function (constraint, pathway) {\n    var self = this;\n    if (self.error)\n      return self;\n\n    // Add the constraint.\n    var newConstraints = self.constraints.push(constraint);\n    // If we already had the constraint, we're done.\n    if (self.constraints === newConstraints)\n      return self;\n\n    self = self._clone();\n    self.constraints = newConstraints;\n    self._addPathway(constraint.name, pathway);\n\n    var chosen = mori.get(self.choices, constraint.name);\n    if (chosen &&\n        !constraint.isSatisfied(chosen, self._resolveContext)) {\n      // This constraint conflicts with a choice we've already made!\n      self.error = util.format(\n        \"conflict: constraint %s is not satisfied by %s.\\n\" +\n        \"Constraints on %s come from:\\n%s\",\n        constraint.toString(),\n        chosen.version,\n        constraint.name,\n        self._shownPathwaysForConstraintsIndented(constraint.name));\n      return self;\n    }\n\n    var alternatives = mori.get(self._dependencies, constraint.name);\n    if (alternatives) {\n      // Note: filter preserves order, which is important.\n      var newAlternatives = filter(alternatives, function (unitVersion) {\n        return constraint.isSatisfied(unitVersion, self._resolveContext);\n      });\n      if (mori.is_empty(newAlternatives)) {\n        self.error = util.format(\n          \"conflict: constraints on %s cannot all be satisfied.\\n\" +\n            \"Constraints come from:\\n%s\",\n          constraint.name,\n          self._shownPathwaysForConstraintsIndented(constraint.name));\n      } else if (mori.count(newAlternatives) === 1) {\n        // There's only one choice, so we can immediately choose it.\n        self = self.addChoice(mori.first(newAlternatives), pathway);\n      } else if (mori.count(newAlternatives) !== mori.count(alternatives)) {\n        self._dependencies = mori.assoc(\n          self._dependencies, constraint.name, newAlternatives);\n      }\n    }\n    return self;\n  },\n  addDependency: function (unitName, pathway) {\n    var self = this;\n\n    if (self.error || mori.has_key(self.choices, unitName)\n        || mori.has_key(self._dependencies, unitName)) {\n      return self;\n    }\n\n    self = self._clone();\n\n    if (!_.has(self._resolver.unitsVersions, unitName)) {\n      self.error = \"unknown package: \" + unitName;\n      return self;\n    }\n\n    // Note: relying on sortedness of unitsVersions so that alternatives is\n    // sorted too (the estimation function uses this).\n    var alternatives = filter(self._resolver.unitsVersions[unitName], function (uv) {\n      return self.isSatisfied(uv);\n      // XXX hang on to list of violated constraints and use it in error\n      // message\n    });\n\n    if (mori.is_empty(alternatives)) {\n      self.error = util.format(\n        \"conflict: constraints on %s cannot be satisfied.\\n\" +\n          \"Constraints come from:\\n%s\",\n        unitName,\n        self._shownPathwaysForConstraintsIndented(unitName));\n      return self;\n    } else if (mori.count(alternatives) === 1) {\n      // There's only one choice, so we can immediately choose it.\n      self = self.addChoice(mori.first(alternatives), pathway);\n    } else {\n      self._dependencies = mori.assoc(\n        self._dependencies, unitName, alternatives);\n      self._addPathway(unitName, pathway);\n    }\n\n    return self;\n  },\n  addChoice: function (uv, pathway) {\n    var self = this;\n\n    if (self.error)\n      return self;\n    if (mori.has_key(self.choices, uv.name))\n      throw Error(\"Already chose \" + uv.name);\n\n    self = self._clone();\n\n    // Does adding this choice break some constraints we already have?\n    if (!self.isSatisfied(uv)) {\n      // This shouldn't happen: all calls to addChoice should occur based on\n      // choosing it from a list of satisfied alternatives.\n      throw new Error(\"try to choose an unsatisfied version?\");\n    }\n\n    // Great, move it from dependencies to choices.\n    self.choices = mori.assoc(self.choices, uv.name, uv);\n    self._dependencies = mori.dissoc(self._dependencies, uv.name);\n    self._addPathway(uv.name, pathway);\n\n    // Since we're committing to this version, we're committing to all it\n    // implies.\n    var pathwayIncludingUv = mori.cons(uv, pathway);\n    uv.constraints.each(function (constraint) {\n      self = self.addConstraint(constraint, pathwayIncludingUv);\n    });\n    _.each(uv.dependencies, function (unitName) {\n      self = self.addDependency(unitName, pathwayIncludingUv);\n    });\n\n    return self;\n  },\n  // this mutates self, so only call on a newly _clone'd and not yet returned\n  // object.\n  _addPathway: function (unitName, pathway) {\n    var self = this;\n    self._unitPathways = mori.assoc(\n      self._unitPathways, unitName,\n      mori.conj(mori.get(self._unitPathways, unitName, mori.set()),\n                pathway));\n  },\n  success: function () {\n    var self = this;\n    return !self.error && mori.is_empty(self._dependencies);\n  },\n  eachDependency: function (iter) {\n    var self = this;\n    mori.some(function (nameAndAlternatives) {\n      return BREAK == iter(mori.first(nameAndAlternatives),\n                           mori.last(nameAndAlternatives));\n    }, self._dependencies);\n  },\n  isSatisfied: function (uv) {\n    var self = this;\n    return self.constraints.isSatisfied(uv, self._resolveContext);\n  },\n  somePathwayForUnitName: function (unitName) {\n    var self = this;\n    var pathways = mori.get(self._unitPathways, unitName);\n    if (!pathways)\n      return mori.list();\n    return mori.first(pathways);\n  },\n  _clone: function () {\n    var self = this;\n    var clone = new ResolverState(self._resolver, self._resolveContext);\n    _.each(['choices', '_dependencies', 'constraints', 'error', '_unitPathways'], function (field) {\n      clone[field] = self[field];\n    });\n    return clone;\n  },\n  _shownPathwaysForConstraints: function (unitName) {\n    var self = this;\n    var pathways = mori.into_array(mori.map(function (pathway) {\n      return showPathway(pathway, unitName);\n    }, mori.get(self._unitPathways, unitName)));\n    pathways.sort();\n    pathways = _.uniq(pathways, true);\n    return pathways;\n  },\n  _shownPathwaysForConstraintsIndented: function (unitName) {\n    var self = this;\n    return _.map(self._shownPathwaysForConstraints(unitName), function (pathway) {\n      return \"  \" + (pathway ? pathway : \"<top level>\");\n    }).join(\"\\n\");\n  }\n});\n\n// Helper for filtering a vector in mori. mori.filter returns a lazy sequence,\n// which is cool, but we actually do want to coerce to a vector since we (eg the\n// estimation function) runs mori.last on it a bunch and we'd like to only\n// do the O(n) work once.\nvar filter = function (v, pred) {\n  return mori.into(mori.vector(), mori.filter(pred, v));\n};\n\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\n// XXX how many copies of this do we have in Meteor?\nvar startsWith = function(str, starts) {\n  return str.length >= starts.length &&\n    str.substring(0, starts.length) === starts;\n};\n\nvar showPathway = function (pathway, dropIfFinal) {\n  var pathUnits = mori.into_array(mori.map(function (uv) {\n    return uv.toString();\n  }, mori.reverse(pathway)));\n\n  var dropPrefix = dropIfFinal + '@';\n  while (pathUnits.length && startsWith(_.last(pathUnits), dropPrefix)) {\n    pathUnits.pop();\n  }\n\n  return pathUnits.join(' -> ');\n};\n","PriorityQueue = function () {\n  var self = this;\n  var compareArrays = function (a, b) {\n    for (var i = 0; i < a.length; i++)\n      if (a[i] !== b[i])\n        if (a[i] instanceof Array)\n          return compareArrays(a[i], b[i]);\n        else\n          return a[i] - b[i];\n\n    return 0;\n  };\n  // id -> cost\n  self._heap = new MinHeap(function (a, b) {\n    return compareArrays(a, b);\n  });\n\n  // id -> reference to item\n  self._items = {};\n};\n\n_.extend(PriorityQueue.prototype, {\n  push: function (item, cost) {\n    var self = this;\n    var id = Random.id();\n    self._heap.set(id, cost);\n    self._items[id] = item;\n  },\n  top: function () {\n    var self = this;\n\n    if (self.empty())\n      throw new Error(\"The queue is empty\");\n\n    var id = self._heap.minElementId();\n    return self._items[id];\n  },\n  pop: function () {\n    var self = this;\n\n    if (self.empty())\n      throw new Error(\"The queue is empty\");\n\n    var id = self._heap.minElementId();\n    var item = self._items[id];\n\n    delete self._items[id];\n    self._heap.remove(id);\n\n    return item;\n  },\n  empty: function () {\n    var self = this;\n    return self._heap.empty();\n  },\n  size: function () {\n    var self = this;\n    return self._heap.size();\n  }\n});\n\n\n"]}